<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta property="og:type" content="website">
<meta property="og:title" content="才权的博客">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="才权的博客">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="才权的博客">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/3/"/>





  <title> 才权的博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?4e94c4c1ded5d320541370545af638ea";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">才权的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/06/《机器学习》笔记-集成学习（8）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liu Caiquan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="才权的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/02/06/《机器学习》笔记-集成学习（8）/" itemprop="url">
                  《机器学习》笔记-集成学习（8）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-06T09:06:08+08:00">
                2018-02-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>由于图片外链被禁止了，图片不能显示，完整文章看这里吧：<a href="https://zhuanlan.zhihu.com/p/33621750" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/33621750</a></p>
<h1 id="写在最前面"><a href="#写在最前面" class="headerlink" title="写在最前面"></a>写在最前面</h1><p>如今机器学习和深度学习如此火热，相信很多像我一样的普通程序猿或者还在大学校园中的同学，一定也想参与其中。不管是出于好奇，还是自身充电，跟上潮流，我觉得都值得试一试。对于自己，经历了一段时间的系统学习（参考<a href="https://zhuanlan.zhihu.com/p/30980999" target="_blank" rel="external">《机器学习/深度学习入门资料汇总》</a>），现在计划重新阅读《机器学习》[周志华]和《深度学习》[Goodfellow et al]这两本书，并在阅读的过程中进行记录和总结。这两本是机器学习和深度学习的入门经典。笔记中除了会对书中核心及重点内容进行记录，同时，也会增加自己的理解，包括过程中的疑问，并尽量的和实际的工程应用和现实场景进行结合，使得知识不只是停留在理论层面，而是能够更好的指导实践。记录笔记，一方面，是对自己先前学习过程的总结和补充。 另一方面，相信这个系列学习过程的记录，也能为像我一样入门机器学习和深度学习同学作为学习参考。</p>
<h1 id="章节目录"><a href="#章节目录" class="headerlink" title="章节目录"></a>章节目录</h1><ul>
<li>个体与集成</li>
<li>Boosting</li>
<li>Bagging与随机森林</li>
<li>集合策略</li>
<li>多样性</li>
</ul>
<h2 id="（一）个体与集成"><a href="#（一）个体与集成" class="headerlink" title="（一）个体与集成"></a>（一）个体与集成</h2><p>集成学习（ensemble learning）的一般结构：先产生一组“个体学习器”（individual learner），再用某种策略将他们结合起来，如下图所示，<br><img src="http://upload-images.jianshu.io/upload_images/4905018-945d7aca6c56b4ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图8.1"><br>个体学习器通常由一个现有的学习算法从训练数据产生：</p>
<ul>
<li>只包含同种类型的个体学习器，这样的集成是“同质”的（homogeneous）。同质集成中的个体学习器亦称为”基学习器“（base learning），相应的学习算法称为”基学习算法“（base learning algorithm）。</li>
<li><p>集成也可包含不同类型的个体学习器，这样集成是”异质“的（heterogeneous）。相应的个体学习器，常称为”组件学习器“（component learning）或直接称为个体学习器。<br>在一般的经验中，如果把好坏不等的东西掺到一起，那么通常结果会是比坏的好一些，比好的要坏一些。集成学习把多个学习器结合起来，如何能获得比最好的单一学习器更好的性能呢？<br>考虑一个简单的例子：在二分类任务中，假定三个分类器在三个测试样本的表现如下图所示，<br><img src="http://upload-images.jianshu.io/upload_images/4905018-1df57820f98630cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图8.2"><br>其中，√表示分类正确，x表示分类错误，集成学习的结果通过投票法（voting）产生，即“少数服从多数”。这个简单的例子显示出：要获得好的集成，个体学习器应“好而不同”。个体学习器要有一定的“准确性”，即学习器不能太坏，而且要有“多样性”（diversity），即学习器之间有差异。事实上，如何产生并结合“好而不同”的个体学习器，恰是集成学习研究的核心。<br>根据个体学习器的生成方式，目前集成学习的方法大致可分为两大类：</p>
</li>
<li><p>个体学习器间存在强依赖关系、必须串行生成的序列化方法，代表是Boosting；</p>
</li>
<li>个体学习器间不存在强依赖关系、可同时生成的并行化方法，代表是Baggig和“随机森林”（Random Forest）；</li>
</ul>
<h2 id="（二）Boosting"><a href="#（二）Boosting" class="headerlink" title="（二）Boosting"></a>（二）Boosting</h2><p>Boosting是一族可将弱学习器提升为强学习器的算法。这族算法的工作机制类似：先从初始训练集训练出一个基学习器，再根据基学习器的表现对训练样本分布进行调整，使得先前基学习器做错的训练样本在后续收到更多的关注，然后基于调整后的样本分布来训练下一个基学习器；如此重复进行，直到基学习器数目达到事先指定的值T，最终将这T个学习器进行加权结合。<br>Boosting族算法最著名的代表是AdaBoost。AdaBoost有多种推导方式，比较容易理解的是基于“加性模型”（additive model）即基学习器线性组合，<br><img src="http://upload-images.jianshu.io/upload_images/4905018-8dbf74c811802eff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.4"><br>来最小化指数损失函数（exponential loss function），<br><img src="http://upload-images.jianshu.io/upload_images/4905018-c6d176a094ead7d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.5"></p>
<h2 id="（三）Bagging与随机森林"><a href="#（三）Bagging与随机森林" class="headerlink" title="（三）Bagging与随机森林"></a>（三）Bagging与随机森林</h2><p>欲得到泛化性能强的集成，集成中的个体学习器应尽可能独立。虽然“独立”在显示任务中无法做到，但可以设法使基学习器尽可能具有较大差异。给定一个训练数据集，一种可能的做法是对训练样本进行采样，产生若干个不同的子集，再从每个数据子集中训练出一个基学习器。这样，由于训练数据不同，我们获得的基学习器可望具有比较大的差异。然而，为获得更好的集成，我们还同时希望个体学习器不能太差。如果采样出的每个子集都完全不同，则每个基学习器只用到了一小部分训练数据，甚至不足进行有效学习，这显然无法确保产生出比较好的基学习器。为考虑这个问题，我们可考虑使用相互有交叠的采样子集。</p>
<h3 id="1-Bagging"><a href="#1-Bagging" class="headerlink" title="1. Bagging"></a>1. Bagging</h3><p>Bagging是并行式集成学习方法最著名的代表，从名字即可看出，它直接基于前面介绍过的自助采样法（bootstrap sampling）。从偏差-方差分解角度看，Bagging主要关注降低方差。</p>
<h3 id="2-随机森林"><a href="#2-随机森林" class="headerlink" title="2. 随机森林"></a>2. 随机森林</h3><p>随机森林（Random Forest，简称RF）是Bagging的一个扩展变体。RF在以决策树为基学习器构建Bagging集成的基础上，进一步在决策树的训练过程中引入了随机属性选择。<br>随机森林对Bagging只做了小改动，但是与Bagging中基学习器的“多样性”仅通过样本扰动（通过对初始训练集采样）而来不同，随机森林中基学习器多样性不仅来自样本扰动，还来自属性扰动，这就使得最终集成的泛化性能可通过个体学习器之间的差异度的增加而进一步提升。</p>
<h2 id="（四）组合策略"><a href="#（四）组合策略" class="headerlink" title="（四）组合策略"></a>（四）组合策略</h2><p>学期器结合可能从三个方面带来好处：</p>
<ul>
<li>从统计的方面看，由于学习任务的假设空间往往很大，可能有多个假设在训练集上达到同等性能，此时若使用单学习器可能因误选而导致泛化性能不佳，结合多个学习器减小这一风险；</li>
<li>从计算的方面来看，学习算法往往会陷入局部极小，有的局部极小点所对应的泛化性能可能很糟，而通过多次运行之后进行结合，可降低陷入糟糕局部极小点的风险；</li>
<li>从表示的方面来看，某些但学习器则肯定无效，而通过结合多个学习器，由于响应的假设空间有所扩大，有可能学得更好的近似。<br>直观的示意图如下所示，<br><img src="http://upload-images.jianshu.io/upload_images/4905018-c5c53a1182e7e3e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图8.8"><br>集成学习常见策略有：</li>
<li>平均法</li>
<li>投票法</li>
<li>学习法</li>
</ul>
<h2 id="（五）多样性"><a href="#（五）多样性" class="headerlink" title="（五）多样性"></a>（五）多样性</h2><h3 id="误差-分歧分解"><a href="#误差-分歧分解" class="headerlink" title="误差-分歧分解"></a>误差-分歧分解</h3><p>欲构建泛化能力强的集成，个体学习器应“好而不同”，其中，“误差-分歧分解”（error-ambiguity decomposition）是一个简单的理论分析方法。但该推到过程只适用于回归学习，难以直接推广到分类学习任务中。</p>
<h3 id="多样性度量"><a href="#多样性度量" class="headerlink" title="多样性度量"></a>多样性度量</h3><p>多样性度量（diversity measure）是用于度量集成中个体分类器的多样性，即估算个体学习器的多样化程度。常用的多样性度量包括：</p>
<ul>
<li>不合度量（disagreement measure）</li>
<li>相关系数（correlation coefficient）</li>
<li>Q-统计量（Q-statistics）</li>
<li>k-统计量（k-statistics）</li>
</ul>
<h3 id="多样性增强"><a href="#多样性增强" class="headerlink" title="多样性增强"></a>多样性增强</h3><p>在集成学习中需有效地生成多样性大的个体学习器。与简单地直接用初始数据训练出个体学习器相比，一般思路是在学习过程中引入随机性，常见的做法主要有，</p>
<ul>
<li>数据样本扰动</li>
<li>输入属性扰动</li>
<li>输出表示扰动</li>
<li>算法参数扰动</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/03/《机器学习》笔记-贝叶斯分类器（7）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liu Caiquan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="才权的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/02/03/《机器学习》笔记-贝叶斯分类器（7）/" itemprop="url">
                  《机器学习》笔记-贝叶斯分类器（7）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-03T09:29:34+08:00">
                2018-02-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>由于图片外链被禁止了，图片不能显示，完整文章看这里吧：<a href="https://zhuanlan.zhihu.com/p/33550090" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/33550090</a></p>
<h1 id="写在最前面"><a href="#写在最前面" class="headerlink" title="写在最前面"></a>写在最前面</h1><p>如今机器学习和深度学习如此火热，相信很多像我一样的普通程序猿或者还在大学校园中的同学，一定也想参与其中。不管是出于好奇，还是自身充电，跟上潮流，我觉得都值得试一试。对于自己，经历了一段时间的系统学习（参考<a href="https://zhuanlan.zhihu.com/p/30980999" target="_blank" rel="external">《机器学习/深度学习入门资料汇总》</a>），现在计划重新阅读《机器学习》[周志华]和《深度学习》[Goodfellow et al]这两本书，并在阅读的过程中进行记录和总结。这两本是机器学习和深度学习的入门经典。笔记中除了会对书中核心及重点内容进行记录，同时，也会增加自己的理解，包括过程中的疑问，并尽量的和实际的工程应用和现实场景进行结合，使得知识不只是停留在理论层面，而是能够更好的指导实践。记录笔记，一方面，是对自己先前学习过程的总结和补充。 另一方面，相信这个系列学习过程的记录，也能为像我一样入门机器学习和深度学习同学作为学习参考。</p>
<h1 id="章节目录"><a href="#章节目录" class="headerlink" title="章节目录"></a>章节目录</h1><ul>
<li>贝叶斯决策论</li>
<li>极大似然估计</li>
<li>朴素贝叶斯分类器</li>
<li>半朴素贝叶斯分类器</li>
<li>贝叶斯网</li>
<li>EM算法</li>
</ul>
<h2 id="（一）贝叶斯决策论"><a href="#（一）贝叶斯决策论" class="headerlink" title="（一）贝叶斯决策论"></a>（一）贝叶斯决策论</h2><p>贝叶斯决策论（Bayesian decision theory）是概率框架下的基本方法。<br>假设有N种可能的类别标记，即y={c1，c2，…，cN}，λij是一个将真实标记为cj的样本误分类为ci产生的期望损失（expected loss），即在样本x上的“条件风险”（conditional rsik），<br><img src="http://upload-images.jianshu.io/upload_images/4905018-e079987c76ecc874.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="7.1"><br>我们的任务是寻找一个判断准则，以最小化总体风险。<br>欲使用贝叶斯判定准则来最小化决策风险，首先要获得后验概率P(c|x)。然而，在现实任务中这通常难以直接获得。从这个角度来看，机器学习所要实现的是基于有限的训练样本尽可能准确的估计出后验证概率P(c|x)。大体来说主要有两种策略：</p>
<ul>
<li>给定x，可通过直接建模P(c|x)来预测c，这样得到的是“判别式模型”（discriminative models）</li>
<li>先对联合概率分布P（x，c）建模，然后再由此获得P（c|x），这样得到的是“生成式模型”（generative models）。<br>显然，前面介绍的决策树、BP神经网络、支持向量机等，都可归入判别式模型的范畴。对于生成式模型来说，必然考虑，<br><img src="http://upload-images.jianshu.io/upload_images/4905018-ee918bcf7cea6371.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="7.7"><br>基于贝叶斯定理可写成，<br><img src="http://upload-images.jianshu.io/upload_images/4905018-8c2c457ff70256fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="7.8"><br>对给定样本x，证据因子P(x)与类标记无关。根据大数定理，先验概率P(c)可通过各类样本出现的频率来进行估计。因此，估计P(x|c)的问题就主要转换为如何基于训练样本D来估计似然P(x|c)。</li>
</ul>
<h2 id="（二）极大似然估计"><a href="#（二）极大似然估计" class="headerlink" title="（二）极大似然估计"></a>（二）极大似然估计</h2><p>估计类条件概率的一种常见策略是先假定其具有某种确定的概率分布形式，再基于训练样本对概率分布的参数进行估计。<br>概率模型的训练过程就是参数估计（parameter estimation）过程。对于参数估计，统计学界的两个学派分别提供了不同的解决方案：</p>
<ul>
<li>频率主义学派（Frequentist）认为参数虽然未知，但确实客观存在的固定值，因此，可通过优化似然函数等准则来确定参数值。</li>
<li>贝叶斯学派（Bayesian）则认为参数是未观察到的随机变量，其本身也有分布，因此，可假设参数服从一个先验分布，然后基于观测到的数据来计算参数的后验分布。<br>书中的介绍来自频率主义学派的极大似然估计（Maximum Likelihood Estimation，简称MLE），这是根据数据采样来估计概率分布参数的经典方法。</li>
</ul>
<h2 id="（三）朴素贝叶斯分类器"><a href="#（三）朴素贝叶斯分类器" class="headerlink" title="（三）朴素贝叶斯分类器"></a>（三）朴素贝叶斯分类器</h2><p>基于贝叶斯公式来估计后验概率P(c|x)的主要困难在于，类条件概率P(x|c)是所有属性上的联合概率，难以从有限的训练样本直接估计而得。为了避开这个障碍，朴素贝叶斯分类器（naive Bayes classifier）采用了“属性条件独立性假设”（attribute conditional independence assumption）。即对已知类别，假设所有属性相互独立。换言之，假设每个属性独立地对分类结果发生影响。<br>基于属性条件独立性假设，条件概率P(c|x)可重写为，<br><img src="http://upload-images.jianshu.io/upload_images/4905018-1286bdbbc17482f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="7.14"><br>其中d为属性数目，xi为x在第i个属性上的取值。<br>由于对所有类别来说P(x)相同，因此贝叶斯判定准则可写为，<br><img src="http://upload-images.jianshu.io/upload_images/4905018-6a7f3ba5c5f7ac3a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="7.15"><br>这就是朴素贝叶斯分类器的表达式。</p>
<h2 id="（四）半朴素贝叶斯分类器"><a href="#（四）半朴素贝叶斯分类器" class="headerlink" title="（四）半朴素贝叶斯分类器"></a>（四）半朴素贝叶斯分类器</h2><p>为了降低贝叶斯公式中估计后验概率P(c|x)的困难，朴素贝叶斯分类器采用了属性条件独立性假设，但在现实任务中这个假设往往很难成立。于是，人们尝试对属性条件独立性假设进行一定程度的放松，因此产生了一类称为“半朴素贝叶斯分类器”（semi-naive Bayes classifiers）的学习方法。</p>
<h2 id="（五）贝叶斯网"><a href="#（五）贝叶斯网" class="headerlink" title="（五）贝叶斯网"></a>（五）贝叶斯网</h2><p>贝叶斯网（Bayesian network）亦称“信念网”（belief network），它借助有向无环图（Directed Acyclic Graph，简称DAG）来刻画属性之间的依赖关系，并使用条件概率表（Conditional Probability Table，简称CPT）来描述属性的联合概率分布。</p>
<h2 id="（六）EM算法"><a href="#（六）EM算法" class="headerlink" title="（六）EM算法"></a>（六）EM算法</h2><p>在前面的讨论中，我们一直假设训练样本所有属性变量的值都已被观测到，即训练样本是“完整”的。但现实应用中往往遇到“不完整”的训练样本。在存在“未观测”变量的情况下，是否仍能对模型参数进行估计呢？<br>EM（Expectation-Maximization）算法就是常用的估计参数隐变量的利器。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/01/《机器学习》笔记-支持向量机（6）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liu Caiquan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="才权的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/02/01/《机器学习》笔记-支持向量机（6）/" itemprop="url">
                  《机器学习》笔记-支持向量机（6）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-01T09:24:47+08:00">
                2018-02-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>由于图片外链被禁止了，图片不能显示，完整文章看这里吧：<a href="https://zhuanlan.zhihu.com/p/33488981" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/33488981</a></p>
<h1 id="写在最前面"><a href="#写在最前面" class="headerlink" title="写在最前面"></a>写在最前面</h1><p>如今机器学习和深度学习如此火热，相信很多像我一样的普通程序猿或者还在大学校园中的同学，一定也想参与其中。不管是出于好奇，还是自身充电，跟上潮流，我觉得都值得试一试。对于自己，经历了一段时间的系统学习（参考<a href="https://zhuanlan.zhihu.com/p/30980999" target="_blank" rel="external">《机器学习/深度学习入门资料汇总》</a>），现在计划重新阅读《机器学习》[周志华]和《深度学习》[Goodfellow et al]这两本书，并在阅读的过程中进行记录和总结。这两本是机器学习和深度学习的入门经典。笔记中除了会对书中核心及重点内容进行记录，同时，也会增加自己的理解，包括过程中的疑问，并尽量的和实际的工程应用和现实场景进行结合，使得知识不只是停留在理论层面，而是能够更好的指导实践。记录笔记，一方面，是对自己先前学习过程的总结和补充。 另一方面，相信这个系列学习过程的记录，也能为像我一样入门机器学习和深度学习同学作为学习参考。</p>
<h1 id="章节目录"><a href="#章节目录" class="headerlink" title="章节目录"></a>章节目录</h1><ul>
<li>间隔与支持向量</li>
<li>对偶问题</li>
<li>核函数</li>
<li>软间隔与正则化</li>
<li>支持向量回归</li>
<li>核方法</li>
</ul>
<h2 id="（一）间隔与支持向量"><a href="#（一）间隔与支持向量" class="headerlink" title="（一）间隔与支持向量"></a>（一）间隔与支持向量</h2><p>给定训练样本D={(x1, y1), (x2, y2), …,(xm, ym)}, yi∈{-1, +1}，分类学习最基本的想法就是基于训练集D在样本空间找到一个划分超平面，<br><img src="http://upload-images.jianshu.io/upload_images/4905018-e2a0a50a780b2287.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图6.1"><br>在样本空间中，划分超平面可通过如下线性方程来描述，<br><img src="http://upload-images.jianshu.io/upload_images/4905018-14f0e487ae2adb5c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.1"><br>假设超平面（w，b）能将训练样本正确分类，即对于(xi, yi)∈D，令，<br><img src="http://upload-images.jianshu.io/upload_images/4905018-c0e86b86fcae79e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.3"><br><img src="http://upload-images.jianshu.io/upload_images/4905018-d21115b5fbd34812.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.2"><br>距离超平面最近的这几个训练样本点称为“支持向量”（support vector），两个异类支持向量到超平面的距离之和为，<br><img src="http://upload-images.jianshu.io/upload_images/4905018-c6609a3b9df5c970.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.4"><br>称为“间隔”（margin）。<br>找到“最大间隔”（maximum margin）的划分超平面，就是支持向量机（Support Vector Machine，简称SVM）的基本型。</p>
<h2 id="（二）对偶问题"><a href="#（二）对偶问题" class="headerlink" title="（二）对偶问题"></a>（二）对偶问题</h2><p>我们对SVM基本型求解是一个凸二次规划（convex quadratic programming）问题，能直接用现成的优化计算包求解，但我们可以有更高效的办法。即对SVM的基本型使用拉格朗日算子法得到其“对偶问题”（dual problem）。</p>
<h2 id="（三）核函数"><a href="#（三）核函数" class="headerlink" title="（三）核函数"></a>（三）核函数</h2><p>在现实任务中，原始样本空间内也许并不存在一个能正确划分两类样本的超平面。对这样的问题，可以将样本从原始空间映射到一个更高维的特征空间，使得样本在这个特征空间内线性可分。如下图，<br><img src="http://upload-images.jianshu.io/upload_images/4905018-9487ce63a2aa3482.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图6.3"><br>幸运的是，如果原始空间是有限维，即属性数有限，那么一定存在一个高维特征空间使样本可分。<br>令Φ(x)表示将x映射后的特征向量，于是，在特征空间中划分超平面所对应的模型可表示为，<br><img src="http://upload-images.jianshu.io/upload_images/4905018-1f88c97dac7235e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.19"><br>其对偶问题是，<br><img src="http://upload-images.jianshu.io/upload_images/4905018-3644ac5183881f0b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.21"><br><img src="http://upload-images.jianshu.io/upload_images/4905018-e82339e6a59ab555.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.21"><br>求解设计到计算，<br><img src="http://upload-images.jianshu.io/upload_images/4905018-d021a06ee3cb2852.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="公式"><br>，这是样本xi与xj映射到特征空间之后的内积。由于特征空间的维数可能很高，甚至可能到无穷维，因此直接计算通常是困难的。为了避开这个障碍，可以假设这样一个函数，<br><img src="http://upload-images.jianshu.io/upload_images/4905018-842fa56f4a4d42af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.22"><br>即xi与xj在特征空间的内积等于他们原始样本空间通过函数k(. , .)计算的结果。有了这样的函数，我们就不必直接计算高维甚至无穷维特征空间中的内积。这里的函数k(. , .)就是“核函数”（kernel function）。<br>“核函数选择”是支持向量机的最大变数。常用的核函数有，<br><img src="http://upload-images.jianshu.io/upload_images/4905018-d4de3923763cd5ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="表6.1"><br>此外，还可以通过函数的组合得到。</p>
<h2 id="（四）软间隔与正则化"><a href="#（四）软间隔与正则化" class="headerlink" title="（四）软间隔与正则化"></a>（四）软间隔与正则化</h2><p>在前面的讨论中，我们一直假定训练样本在训练空间或特征空间中是线性可分的，即存在一个超平面将不同类的样本完全划分开。然而，在现实任务中往往很难确定合适的核函数使得训练样本在特征空间中线性可分。<br>缓解该问题的一个办法是允许支持向量机在一些样本上出错。为此引入了“软间隔”（soft margin）的概念，如下图所示，<br><img src="http://upload-images.jianshu.io/upload_images/4905018-e5bedcbf218084db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图6.4"><br>具体来说，前面介绍的支持向量机形式是要求所有样本均满足约束，即所有样本必须划分正确，这称为“硬间隔”（hard margin），而软间隔则是允许这样的样本不满足约束。</p>
<h2 id="（五）支持向量回归"><a href="#（五）支持向量回归" class="headerlink" title="（五）支持向量回归"></a>（五）支持向量回归</h2><p>对样本（x，y），传统回归模型通常直接基于模型输出f(x)与真实输出y之间的差别来计算损失，当切仅当f(x)与y完全相同时，损失才为零。于此不同，支持向量回归（Support Vector Regression，简称SVR）假设我们能容忍f(x)与y之间最多有ε的偏差，即仅当f(x)与y之间的差别绝对值大于ε时才计算损失。如下图所示，<br><img src="http://upload-images.jianshu.io/upload_images/4905018-b3cab0fae8d31bc7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图6.6"></p>
<h2 id="（六）核方法"><a href="#（六）核方法" class="headerlink" title="（六）核方法"></a>（六）核方法</h2><p>根据“表示定理”，对于一般的损失函数和正则化项（不要求是凸函数），优化问题的最优解都可表示为核函数的线性组合。这显示出核函数的巨大威力。<br>人们发展出一系列基于核函数的学习方法，统称为“核方法”（kernel methods）。最常见的，是通过“核化”（即引入核函数）来将线性学习器拓展为非线性学习器。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/30/《机器学习》笔记-神经网络（5）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liu Caiquan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="才权的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/01/30/《机器学习》笔记-神经网络（5）/" itemprop="url">
                  《机器学习》笔记-神经网络（5）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-30T11:14:33+08:00">
                2018-01-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>由于图片外链被禁止了，图片不能显示，完整文章看这里吧：<a href="https://zhuanlan.zhihu.com/p/33422780" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/33422780</a></p>
<h1 id="写在最前面"><a href="#写在最前面" class="headerlink" title="写在最前面"></a>写在最前面</h1><p>如今机器学习和深度学习如此火热，相信很多像我一样的普通程序猿或者还在大学校园中的同学，一定也想参与其中。不管是出于好奇，还是自身充电，跟上潮流，我觉得都值得试一试。对于自己，经历了一段时间的系统学习（参考<a href="https://zhuanlan.zhihu.com/p/30980999" target="_blank" rel="external">《机器学习/深度学习入门资料汇总》</a>），现在计划重新阅读《机器学习》[周志华]和《深度学习》[Goodfellow et al]这两本书，并在阅读的过程中进行记录和总结。这两本是机器学习和深度学习的入门经典。笔记中除了会对书中核心及重点内容进行记录，同时，也会增加自己的理解，包括过程中的疑问，并尽量的和实际的工程应用和现实场景进行结合，使得知识不只是停留在理论层面，而是能够更好的指导实践。记录笔记，一方面，是对自己先前学习过程的总结和补充。 另一方面，相信这个系列学习过程的记录，也能为像我一样入门机器学习和深度学习同学作为学习参考。</p>
<h1 id="章节目录"><a href="#章节目录" class="headerlink" title="章节目录"></a>章节目录</h1><ul>
<li>神经元模型</li>
<li>感知机与多层网络</li>
<li>误差逆传播算法</li>
<li>全局最小与局部最小</li>
<li>其他常见神经网络</li>
<li>深度学习</li>
</ul>
<h2 id="（一）神经元模型"><a href="#（一）神经元模型" class="headerlink" title="（一）神经元模型"></a>（一）神经元模型</h2><p>神经网络（neural networks）方面的研究很早就已出现，其中最基本的元素是神经元（neuron）模型。1943年，McCulloch 和Pitts提出一直沿用至今的“M-P神经元模型”，如下图所示，<br><img src="http://upload-images.jianshu.io/upload_images/4905018-7d4f0b9225375513.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图5-1"><br>在这个模型中，神经元接收到来自n个其他神经元传递过来的输入信息，这些输入信号通过带权重的连接（connection）进行传递，神经元接收到的总输入值将与神经元的阈值进行比较，然后通过“激活函数”（activation function）处理以产生神经元的输出。<br>理想激活函数是阶跃函数（下图所示）。然而，阶跃函数具有不连续、不光滑等不太好的性质，因此实际常用sigmoid函数作为激活函数。<br><img src="http://upload-images.jianshu.io/upload_images/4905018-76644a7217042923.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图5.2"><br>把神经元按一定的层次结构连接起来，就得到了神经网络。</p>
<h2 id="（二）感知机与多层网络"><a href="#（二）感知机与多层网络" class="headerlink" title="（二）感知机与多层网络"></a>（二）感知机与多层网络</h2><p>感知机（perceptron）由两层神经元组成，如下图所示，<br><img src="http://upload-images.jianshu.io/upload_images/4905018-7b10568f632d9939.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图5.3"><br>感知机只有输出层神经元进行激活函数处理，即只拥有一层功能神经元（function neuron），其学习能力非常有限。可以证明，若两类模式是线性可分（linearly separable）的问题，即存在一个线性超平面将它们分开，则感知机学习过程一定会收敛（converge）。否则，感知机学习过程将发生震荡（fluctuation），不能求得合适解。<br>要解决非线性可分问题，需考虑使用多层神经元功能，<br><img src="http://upload-images.jianshu.io/upload_images/4905018-15c2291a90bcaee3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图5.5"><br>输入层与输出层之间的一层神经元被称为隐层或隐含层（hidden layer），隐含层和输出层神经元都是拥有激活函数的功能神经元。<br>神经网络的学习过程，就是根据训练数据来调整神经元之间的“连接权”（connection weight）以及每个功能神经元的阈值；换言之，神经网络“学”到的东西，蕴含在连接权和阈值中。</p>
<h2 id="（三）误差逆传播算法"><a href="#（三）误差逆传播算法" class="headerlink" title="（三）误差逆传播算法"></a>（三）误差逆传播算法</h2><p>误差传播（erro BackPropagation，简称BP）算法是求解多层网络算法中最杰出的代表，它是迄今最成功的神经网络学习算法。现实任务中使用神经网络时，大多是使用BP算法进行训练。值得指出的是，BP算法不仅可用于多层前馈神经网络，还可以用于其他类型的神经网络，如递归神经网络。<br>BP算法基于梯度下降（gradient）策略，以目标的负梯度方向对参数进行调整。（数学推到过程省略）<br>[Hornik et al. 1989]证明，只需一个包含足够神经元的隐层，多层前馈网络就能以任意精度逼近任意复杂度的连续函数。然而，如何设置隐层神经元的个数仍是个未决问题，实际应用中通常靠“试错法”（trial-by-error）调整。<br>BP神经网络经常遭遇过拟合，其训练误差持续降低，但测试误差却可能上升。有两种策略常用来缓解BP网络的过拟合。</p>
<ul>
<li>“早停”（early stopping）<br>将数据分成训练集和验证集，训练集用来计算梯度、更新连接权和阈值，验证集用来估计误差。若训练集误差降低但验证集误差升高，则停止训练，同时，返回具有最小验证集误差的连接权和阈值。</li>
<li>正则化（regularization）<br>基本思想是在误差目标函数中增加一个用于描述网络复杂度的部分，例如连接权与阈值的平方和。令Ek表示第k个训练样例上的误差，wi表示连接权和阈值，则误差目标函数改写为，<br><img src="http://upload-images.jianshu.io/upload_images/4905018-60c9bcbf1bd6d8e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.17"><br>其中，λ∈(0，1)用于对经验误差与网络复杂度这两项进行折中，通过交叉验证来估计。</li>
</ul>
<h2 id="（四）全局最小与局部极小"><a href="#（四）全局最小与局部极小" class="headerlink" title="（四）全局最小与局部极小"></a>（四）全局最小与局部极小</h2><p>若用E表示神经网络在训练集上的误差，则它显然是关于连接权w和阈值θ的函数。此时，神经网络的训练过程可看做一个参数寻优过程，即在参数空间中，寻找一组最优参数使得E最小。<br>直观地看，局部极小解是参数空间的某个点，其邻域点的误差函数值均不小于该点的函数值；全局最小解则是指参数空间中的所有点误差均不小于该点的误差函数值。两者对应的E(w<em>,θ</em>)分别称为误差函数的局部极小值和全局最小值。<br>基于梯度的搜索是使用最为广泛的参数寻优方法。在此类方法中，我们从某些初始解出发，迭代寻找最优参数值。每次迭代中，我们先计算误差函数在当前点的梯度，然后根据梯度确定搜索方向。若误差函数在当前点的梯度为零，则已达到局部极小，更新量将为零，这意味着参数的迭代更新将在此停止。显然，如果误差函数仅有一个局部极小，那么此时找到的局部极小就是全局最下。然而，如果误差函数具有多个局部极小，则不能保证找到的解释全局最小。对后一种情形，我们称参数寻优陷入局部极小，这显然不是我们所希望的。<br>在现实任务中，人们常采用以下策略来试图“跳出”局部极小，从而进一步接近全局最小：</p>
<ul>
<li>以多组不同参数值初始化多个神经网络，按标准方法训练后，取其中误差最小的解作为最终参数。</li>
<li>使用“模拟退火”（simulated annealing）技术<br>模拟退火在每一步都以一定的概率接受比当前解更差的结果，从而有助于“跳出”局部极小。</li>
<li>使用随机梯度下降<br>与标准梯度下降法精确计算梯度不同，随机梯度下降法在计算梯度时加入随机因素。于是，即使陷入局部极小点，它计算出的梯度仍可能不为零，这样就有机会跳出局部极小继续搜索。<br>此外，遗传算法（genetic algorithms）也常用来训练神经网络更好的逼近全局最小。需要注意的是，上述用于跳出局部极小的技术大多是启发式，理论上尚缺乏保障。</li>
</ul>
<h2 id="（五）其他常见神经网络"><a href="#（五）其他常见神经网络" class="headerlink" title="（五）其他常见神经网络"></a>（五）其他常见神经网络</h2><h3 id="1-RBF网络"><a href="#1-RBF网络" class="headerlink" title="1. RBF网络"></a>1. RBF网络</h3><p>RBF（Radial Basis Function，径向基函数）网络是一种单隐层前馈神经网络，它使用径向基函数作为隐藏层神经元激活函数，而输出层则是对隐层神经元输出的线性组合。</p>
<h3 id="2-ART网络"><a href="#2-ART网络" class="headerlink" title="2. ART网络"></a>2. ART网络</h3><p>竞争型学习（competitive learning）是神经网络中一种常用的无监督学习策略，使用该策略时，网络的输出神经元相互竞争，每一时刻仅有一个竞争获胜的神经元被激活，其他神经元状态被抑制。这种机制亦称为“胜者通吃”（winner-take-all）原则。<br>ART（Adaptive Resonance Theory，自适应谐振理论）网络是竞争型学习的重要代表。ART比较好地缓解了竞争型学习中的“可塑性-稳定性窘境”（stability-plasticity dilemma）。</p>
<h3 id="3-SOM网络"><a href="#3-SOM网络" class="headerlink" title="3. SOM网络"></a>3. SOM网络</h3><p>SOM（Self-Organizing Map，自组织映射）网络是一种竞争学习型的无监督神经网络，他能将高维输入数据映射到低维空间（通常为二维），同时保持输入数据在高维空间的拓扑结构，即将高维空间中相似的样本点映射到网络输出层中的邻近神经元。</p>
<h3 id="4-级联相关网络"><a href="#4-级联相关网络" class="headerlink" title="4. 级联相关网络"></a>4. 级联相关网络</h3><p>一般的神经网络模型通常假定网络结构是事先固定的，训练的目的是利用训练样本来确定合适的连接权、阈值等参数。与此不同，结构自适应网络则将网络结构也当做学习目标之一，并希望能在训练过程中能找到最符合数据特点的网络结构。级联相关（cascade-Correlation）网络是结构自适应网络的重要代表。</p>
<h3 id="5-Elman网络"><a href="#5-Elman网络" class="headerlink" title="5. Elman网络"></a>5. Elman网络</h3><p>与前馈神经网络不同，“递归神经网络”（recurrent neural networks）允许网络中出现环形结构，从而可让一些神经元的输出反馈回来作为输入信号。这样的结构与信息反馈过程，使得网络在t时刻的输出状态不仅与t时刻的输入有关，还与t-1时刻的网络状态有关，从而能处理与时间有关的动态变化。Elman网络是最常用的递归神经网络之一，结构如下图所示，<br><img src="http://upload-images.jianshu.io/upload_images/4905018-be7be7fa5b76cdd5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图5.13"></p>
<h3 id="6-Boltzmann机"><a href="#6-Boltzmann机" class="headerlink" title="6. Boltzmann机"></a>6. Boltzmann机</h3><p>神经网络中有一类模型是为网络状态定义一个“能量”（energy），能量最小化时网络达到理想状态，而网络的训练就是在最小化这个能量函数。Boltzmann机就是一种“基于能量的模型”（energy-based model）。</p>
<h2 id="（六）深度学习"><a href="#（六）深度学习" class="headerlink" title="（六）深度学习"></a>（六）深度学习</h2><p>典型的深度学习模型就是很深的神经网络。显然，对神经网络模型，提高容量的一个简单办法是增加隐层的数目。隐层多了，相应的神经元连接权、阈值等参数就会更多。模型复杂度也可通过单纯增加隐层神经元的数目来实现，前面我们谈到过，单隐层的多层前馈网络已具有很强大的学习能力；但从增加模型复杂度的角度来看，增加隐层数目显然比增加隐层神经元的数目更有效，因为增加隐层数不仅增加了拥有激活函数的神经元数目，还增加了激活函数嵌套的层数。然而，多隐层神经网络难以直接用经典算法（例如标准BP算法）进行训练，因为误差在多隐层内逆传播时，往往会“发散”（diverge）而不能收敛到稳定状态。<br>无监督逐层训练（unsupervised layer-wise training）是多隐层网络训练的有效手段。例如，在深度信念网络（deep belief network，检查DBN）中，每层都是一个受限Boltzmann机，即整个网络可视为若干个RBM堆叠而成。<br>另一种节省训练开销的策略是“权共享”（weigh sharing），即让一组神经元使用相同的连接权。这个策略在卷积神经网络（Convolutional Neural Network，简称CNN）中发挥重要作用。<br>无论是DBN还是CNN，其多隐层堆叠、每层对上一层输出进行处理的机制，可看做是在输入信号进行逐层加工，从而把初始的、与输出目标之间联系不太密切的输入表示，转化成与输出目标联系更密切的表示，使得原来仅基于最后一层输出映射难以完成的任务成为可能。换言之，通过多层处理，逐渐将初始的“低层”特征表示转化为“高层”特征表示后，用“简单模型”即可完成复杂的分类等学习任务。因此可将深度学习理解为进行“特征学习”（feature Learning）或“表示学习”（representation learning）。<br>以往在机器学习用于现实任务时，描述样本的特征通常需由人类专家来设计，这称为“特征工程”（feature engineering）。众所周知，特征好坏对泛化性能有至关重要的影响，人类专家设计出好特征也并非易事；特征学习则通过机器学习技术自身来产生好特征，这使机器学习向“全自动数据分析”又前进了一步。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/28/《机器学习》笔记-决策树（4）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liu Caiquan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="才权的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/01/28/《机器学习》笔记-决策树（4）/" itemprop="url">
                  《机器学习》笔记-决策树（4）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-28T10:52:31+08:00">
                2018-01-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>由于图片外链被禁止了，图片不能显示，完整文章看这里吧：<a href="https://zhuanlan.zhihu.com/p/33364067" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/33364067</a></p>
<h1 id="写在最前面"><a href="#写在最前面" class="headerlink" title="写在最前面"></a>写在最前面</h1><p>如今机器学习和深度学习如此火热，相信很多像我一样的普通程序猿或者还在大学校园中的同学，一定也想参与其中。不管是出于好奇，还是自身充电，跟上潮流，我觉得都值得试一试。对于自己，经历了一段时间的系统学习（参考<a href="https://zhuanlan.zhihu.com/p/30980999" target="_blank" rel="external">《机器学习/深度学习入门资料汇总》</a>），现在计划重新阅读《机器学习》[周志华]和《深度学习》[Goodfellow et al]这两本书，并在阅读的过程中进行记录和总结。这两本是机器学习和深度学习的入门经典。笔记中除了会对书中核心及重点内容进行记录，同时，也会增加自己的理解，包括过程中的疑问，并尽量的和实际的工程应用和现实场景进行结合，使得知识不只是停留在理论层面，而是能够更好的指导实践。记录笔记，一方面，是对自己先前学习过程的总结和补充。 另一方面，相信这个系列学习过程的记录，也能为像我一样入门机器学习和深度学习同学作为学习参考。</p>
<h1 id="章节目录"><a href="#章节目录" class="headerlink" title="章节目录"></a>章节目录</h1><ul>
<li>基本流程</li>
<li>划分选择</li>
<li>减枝处理</li>
<li>连续与缺失值</li>
<li>多变量决策树</li>
</ul>
<h2 id="（一）基本流程"><a href="#（一）基本流程" class="headerlink" title="（一）基本流程"></a>（一）基本流程</h2><p>一般的，一颗决策树包含一个根节点，若干个内部节点和若干个叶子节点；叶子节点对应决策结果，其他每个节点对应一个属性测试；每个节点包含的样本集合根据属性测试的结果被划分到子节点中；根节点包含样本全集，从根节点到每个叶子节点的路径对应了一个判定测试序列。决策树学习的目的是为了产生一颗泛化能力强，即处理未见示例能力强的决策树，基本形式如下图所示（判别习惯是否为好瓜的决策树）：<br><img src="http://upload-images.jianshu.io/upload_images/4905018-8f64e569236e3574.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图4.1"></p>
<h2 id="（二）划分选择"><a href="#（二）划分选择" class="headerlink" title="（二）划分选择"></a>（二）划分选择</h2><p>决策树学习的关键，是如何选择最优划分属性。一般而言，随着划分过程的不断进行，我们希望决策树的分支节点所包含的样本尽可能属于同一类别，即节点的“纯度”越来越高。</p>
<h3 id="信息增益"><a href="#信息增益" class="headerlink" title="信息增益"></a>信息增益</h3><p>“信息熵”（information entropy）是度量样本集合纯度最常用的一种指标。假定当前集合D中第k类样本所占的比例为pk（k=1,2,…,|y|），则D的信息熵定义为，<br><img src="http://upload-images.jianshu.io/upload_images/4905018-549ea373f7d99659.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.1"><br>Ent(D)的值越小，则D的纯度越高。<br>假定离散属性a有V个可能的取值，<br><img src="http://upload-images.jianshu.io/upload_images/4905018-618b4b1951ea8c11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="公式"><br>若使用a来对样本集合D进行划分，则会产生V个分支节点，其中第v个分支点包含了D中所有在属性a上取值为a(v)的样本，记为D(v)。根据信息熵可计算出属性a对样本集D进行划分所获得的“信息增益”（information gain），<br><img src="http://upload-images.jianshu.io/upload_images/4905018-f5da6bc589b1a59e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.2"><br>一般而言，信息增益越大，则意味着使用属性a来进行划分所获得的“纯度提升”越大。因此，我们可用信息增益来进行决策树的划分属性选择。著名的ID3决策树学习算法就是以信息增益为准则来选择划分属性的。</p>
<h3 id="增益率"><a href="#增益率" class="headerlink" title="增益率"></a>增益率</h3><p>信息增益准则对可取值数目较多的属性有所偏好，为了减少这种偏好可能带来的不利影响，著名的C4.5决策树算法不直接使用信息增益，而使用“增益率”（gain ratio）来选择最优划分属性。增益率定义为，<br><img src="http://upload-images.jianshu.io/upload_images/4905018-57b3e059ad0d099b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.3"><br>其中，<br><img src="http://upload-images.jianshu.io/upload_images/4905018-d24a4f9077d8d2d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.4"></p>
<h3 id="基尼指数"><a href="#基尼指数" class="headerlink" title="基尼指数"></a>基尼指数</h3><p>CART决策树使用“基尼指数”（Gini index）来选择划分属性，<br><img src="http://upload-images.jianshu.io/upload_images/4905018-e49edf41513c6112.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.5"><br>直观说，Gini(D)反应了从数据集D中随机抽取两个样本，其类别标记不一致的概率。因此，Gini(D)越小，则数据集D的纯度越高。</p>
<h2 id="（三）剪枝处理"><a href="#（三）剪枝处理" class="headerlink" title="（三）剪枝处理"></a>（三）剪枝处理</h2><p>剪枝（pruning）是决策树学习算法对付”过拟合“的主要手段。<br>决策树剪枝的基本策略有”预剪枝“（prepruning）和”后剪枝“（post-pruning）。预剪枝是指在决策树生成过程中，对每个节点在划分前进行估计，若当前的划分不能带来决策树泛化性能提升，则停止划分并将当前节点标记为叶节点；后剪枝是先从训练集生成一颗完整的决策树，然后自底向上的对非叶节点进行考察，若将该节点对应的子树替换为叶节点能带来决策树泛化性能提升，则将该子树替换为叶节点。<br>剪枝处理降低了”过拟合“风险，但也带来了”欠拟合“的风险。<br>一般情形下，后剪枝决策树欠拟合风险较小，泛化性能往往优于预剪枝决策树。但后剪枝训练开销比未剪枝决策树和预剪枝决策树都要大很多。</p>
<h2 id="（四）连续与缺失值"><a href="#（四）连续与缺失值" class="headerlink" title="（四）连续与缺失值"></a>（四）连续与缺失值</h2><p>到目前为止我们讨论了基于离散属性来生成决策树。现实学习任务中常会遇到连续属性。此时 ，连续属性离散化技术可派上用场。最简单的策略是采用二分法（bi-partition）。<br>现实任务中常会遇到不完整样本，即样本的某些属性值缺失。我们需要解决两个问题：</p>
<ul>
<li>如何在属性值缺失的情况下进行划分属性选择？</li>
<li>给定划分属性，若样本在该属性上的值缺失，如何对样本进行划分？</li>
</ul>
<h2 id="（五）多变量决策树"><a href="#（五）多变量决策树" class="headerlink" title="（五）多变量决策树"></a>（五）多变量决策树</h2><p>若我们把每个属性视为坐标空间的一个坐标轴，则d个属性描述的样本就对应了d维空间的一个数据点，对样本分类则意味着在这个坐标空间中寻找不同样本之间的分类边界。决策树所形成的分类边界有一个明显的特点：轴平行（axis-parallel），即它的分类边界由若干个与坐标轴平行的分段组成。<br>显然，分类边界的每一段都与坐标轴平行的。这样的分类边界使得学习结果又较好的可解释性，因为每一段划分都直接对应了某个属性取值。但在学习任务的真实分类边界比较复杂时，必须使用很多段划分才能取得较好的近似，此时的决策树会相当复杂，由于要进行大量的属性测试，预测时间开销会很大。<br>若能使用斜的划分边界，则决策树模型将大为简化。“多变量决策树”（multivariate decision tree）就是能实现这样的“斜划分”甚至更负责划分的决策树。如下图所示，<br><img src="http://upload-images.jianshu.io/upload_images/4905018-3e3609bcf3822966.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图4.12"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/25/《机器学习》笔记-线性模型（3）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liu Caiquan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="才权的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/01/25/《机器学习》笔记-线性模型（3）/" itemprop="url">
                  《机器学习》笔记-线性模型（3）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-25T08:52:10+08:00">
                2018-01-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>由于图片外链被禁止了，图片不能显示，完整文章看这里吧：<a href="https://zhuanlan.zhihu.com/p/33270877" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/33270877</a></p>
<h1 id="写在最前面"><a href="#写在最前面" class="headerlink" title="写在最前面"></a>写在最前面</h1><p>如今机器学习和深度学习如此火热，相信很多像我一样的普通程序猿或者还在大学校园中的同学，一定也想参与其中。不管是出于好奇，还是自身充电，跟上潮流，我觉得都值得试一试。对于自己，经历了一段时间的系统学习（参考<a href="https://zhuanlan.zhihu.com/p/30980999" target="_blank" rel="external">《机器学习/深度学习入门资料汇总》</a>），现在计划重新阅读《机器学习》[周志华]和《深度学习》[Goodfellow et al]这两本书，并在阅读的过程中进行记录和总结。这两本是机器学习和深度学习的入门经典。笔记中除了会对书中核心及重点内容进行记录，同时，也会增加自己的理解，包括过程中的疑问，并尽量的和实际的工程应用和现实场景进行结合，使得知识不只是停留在理论层面，而是能够更好的指导实践。记录笔记，一方面，是对自己先前学习过程的总结和补充。 另一方面，相信这个系列学习过程的记录，也能为像我一样入门机器学习和深度学习同学作为学习参考。</p>
<h1 id="章节目录"><a href="#章节目录" class="headerlink" title="章节目录"></a>章节目录</h1><ul>
<li>基本形式</li>
<li>线性回归</li>
<li>对数几率回归</li>
<li>线性判别分析</li>
<li>多分类学习</li>
<li>类别不平衡问</li>
</ul>
<h2 id="（一）基本形式"><a href="#（一）基本形式" class="headerlink" title="（一）基本形式"></a>（一）基本形式</h2><p>给定d个属性描述示例x=(x1;x2;…;xd)，其中xi是x在第i个属性上的取值，线性模型（linear model）试图学得一个通过属性的线性组合来进行预测的函数，即，<br><img src="http://upload-images.jianshu.io/upload_images/4905018-3b01efbc6f4f3398.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.1"><br>一般用向量形式写成，<br><img src="http://upload-images.jianshu.io/upload_images/4905018-a72e2b67c4546560.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.2"><br>其中，w=（w1;w2;…;wd）。w和b学得之后，模型就得以确定。</p>
<h2 id="（二）线性回归"><a href="#（二）线性回归" class="headerlink" title="（二）线性回归"></a>（二）线性回归</h2><p>给定数据集D={(x1,y1),(x2,y2),…,(xm,ym)}，其中，xi=(xi1;xi2;…;xid)，yi∈R。“线性回归”（linear regression）试图学得一个线性模型以尽可能准确的预测实际输出标记。<br>我们先考虑一种最简单的情况：输入属性的数目只有一个。线性回归试图学得，<br><img src="http://upload-images.jianshu.io/upload_images/4905018-bfff87632cc860c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.3"></p>
<p>如何确定w和b呢？显然，关键在于如何衡量f(x)与y之间的差别。第二章中介绍过，均方误差是回归任务中常用的性能度量，因此我们可以试图让均方误差最小化，即，<br><img src="http://upload-images.jianshu.io/upload_images/4905018-9f2d5064b445824a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.4"><br>均方误差有非常好的几何意义，它对应了常用的欧几里得距离或简称“欧式距离”（Euclidean distance）。基于均方误差最小化进行模型求解的方法称为“最小二乘法”（least square method）。在线性回归中，最小二乘法就是输入找到一条直线，使所有样本到直线上的欧式距离之和最小。<br>求解w和b使，<br><img src="http://upload-images.jianshu.io/upload_images/4905018-86211addcc5e6aae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="期望"><br>最小化的过程，称为线性回归模型的最小二乘“参数估计”（parameter estimation）。我们可以将E(w,b)分别对w和b求导，得到，<br><img src="http://upload-images.jianshu.io/upload_images/4905018-a96176cb36d400ee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.5，3.6"><br>然后，领上面的式子为零，从而求得w和b的最优解，<br><img src="http://upload-images.jianshu.io/upload_images/4905018-3a3b8d5661f2f16f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.7"><br><img src="http://upload-images.jianshu.io/upload_images/4905018-758a199ddd864037.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.8"><br>更一般的情况是数据集D，样本由d个属性描述。此时我们试图学得，<br><img src="http://upload-images.jianshu.io/upload_images/4905018-4dba383472b1915b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="样本多属性"><br>这称为“多元线性回归”（multivariate linear regression）。<br>类似的，可利用最小二乘法来对w和b进行估计。为了便于讨论，我们把w和b吸入向量形式，<br><img src="http://upload-images.jianshu.io/upload_images/4905018-7aa8be8cca1e5cad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="w,b向量形式"><br>相应的，把数据集D表示为一个mx(d+1)大小的矩阵X，其中，每行对应于一个示例，该行前d个元素对应于示例的d个属性值，最后一个元素恒置为1，即，<br><img src="http://upload-images.jianshu.io/upload_images/4905018-8548771c3151715b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="矩阵X"><br>再把标记也写成向量形式y=(y1;y2;…;ym)，则有，<br><img src="http://upload-images.jianshu.io/upload_images/4905018-743937b3a5e9726c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.9"><br>当[公式2-1]<br><img src="http://upload-images.jianshu.io/upload_images/4905018-98122131b0824eb5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="公式2-1"><br>为满秩矩阵（full-rank matrix）或正定矩阵（positive definite matrix）时，可求得，<br><img src="http://upload-images.jianshu.io/upload_images/4905018-56450bd27b55db05.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.11"><br>然而，显示任务中[公式2-1]往往不是满秩矩阵。例如许多任务中我们会遇到大量的变量，其数目甚至超过样例数，导致X的列数大于行数，[公式2-1]显然不满秩。此时可解出多个w，他们都能使均方误差最小化。选择哪一个最为输出，将由学习算法的归纳偏好决定，常见的做饭是引入正则化（regularization）项。<br>更一般地，考虑单调可微函数g(.)，令<br><img src="http://upload-images.jianshu.io/upload_images/4905018-0decc0db32a0f274.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.15"><br>这样得到的模型称为“广义线性模型”（generalized linear model）。</p>
<h2 id="（三）对数几率回归"><a href="#（三）对数几率回归" class="headerlink" title="（三）对数几率回归"></a>（三）对数几率回归</h2><p>上一节讨论了如何使用线性模型进行回归学习，但若要做的是分类任务该怎么办？这里可以考虑广义线性模型：只要找到一个单调可微函数将分类任务的真实标记y与线性回归模型的预测值联系起来。<br>考虑二分任务，其输出标记y∈{0，1}，而线性回归模型产生的预测值，<br><img src="http://upload-images.jianshu.io/upload_images/4905018-e60506522df5f8d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="公式"><br>是实值，于是，我们需将实值z转换为0/1值。最理想的是单位阶跃函数（unit-step function）。<br>但单位阶跃函数不连续，因此不能作为广义线性模型。于是我们希望找到能在一定程度上近似单位阶跃函数的“替代函数”（surrogate function），并希望它单调可微分。对数几率函数（logistic function）正是这样一个常用的替代函数（Sigmoid函数）：<br><img src="http://upload-images.jianshu.io/upload_images/4905018-7f7d5e98751e2451.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.17"><br>即，<br><img src="http://upload-images.jianshu.io/upload_images/4905018-a55fcebcc3245fe7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.18"></p>
<p>函数如下图所示，<br><img src="http://upload-images.jianshu.io/upload_images/4905018-786444a5810b0d94.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图3.2"><br>下面我们来看如何确定w和b，<br><img src="http://upload-images.jianshu.io/upload_images/4905018-830a4b3fb420769b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.23，3.24"><br>我们可以通过“极大似然法”（maximum likelihood method）来估计w和b，<br><img src="http://upload-images.jianshu.io/upload_images/4905018-07000a7ae1b8956c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.25"><br>根据凸优化理论，经典的数值优化算法如梯度下降法（gradient descent method）、牛顿法（Newton method）都可以求得最优解。</p>
<h2 id="（四）线性判别分析"><a href="#（四）线性判别分析" class="headerlink" title="（四）线性判别分析"></a>（四）线性判别分析</h2><p>线性判别分析（Linear Discriminant Analysis，简称LDA）的思想非常朴素：给定训练样例集，设法将样例投影到一条直线上，使得同样样例的投影点尽可能接近，异类样例的投影点尽可能远离；对新样本进行分类时，将其投影到同样的这条直线上，再根据投影点的位置确定新样本的类别，如下图所示，<br><img src="http://upload-images.jianshu.io/upload_images/4905018-4eec5600ee6fbfb0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图3.3"><br>多分类LDA将样本投影到d’维空间，d’通常小于数据原有的属性数d,于是通过这个投影来减小样本点的维数，且投影过程中使用了类别信息，因此LDA也常被视为一种经典的监督降维技术。</p>
<h2 id="（五）多分类学习"><a href="#（五）多分类学习" class="headerlink" title="（五）多分类学习"></a>（五）多分类学习</h2><p>现实中常遇到多分类学习任务。有些二分类学习方法可直接推广到多分类。<br>考虑N个类别C1,C2,…,CN，多分类学习的基本思路是“拆解法”，即将多分类任务拆为若干若干个二分类任务求解。具体来说，先对问题进行拆分，然后为拆出的每个二分类任务训练一个分类器；在测试时，对这些分类器的预测结果进行集成以获得最终的分类结果。<br>最经典的分类拆分策略有三种：</p>
<ul>
<li>“一对一”（One vs One，简称OvO）</li>
<li>“一对其余”（One vs Rest，简称OvR）</li>
<li>“多对多”（Many vs Many）。</li>
</ul>
<p>多分类过程如下图所示（OvO与OvR示意图），<br><img src="http://upload-images.jianshu.io/upload_images/4905018-99f3730369210654.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图3.4"></p>
<h2 id="（六）类别不平衡问题"><a href="#（六）类别不平衡问题" class="headerlink" title="（六）类别不平衡问题"></a>（六）类别不平衡问题</h2><p>前面介绍的分类学习方法都有一个共同的基本假设，即不同类别的训练样例数目相当。如果不同类别的训练样例数目稍有差别，通常影响不大，但若差别很大，则会对学习过程造成困扰。<br>针对这种情况，现有技术上塔体有三类做法（假定正类样例较少，反例样例较多）：</p>
<ul>
<li>第一类是直接对训练集里的反例样本进行“欠采样”（undersampling），即去除一些反例使得正、反例数目接近，然后在进行学习；</li>
<li>第二类是对训练集里的正类样例进行“过采样”（oversampling），即增加一些正例使得正、反例数目接近，然后再进行学习；</li>
<li>第三类则是直接基于原始训练集进行学习，但在用训练好的分类器进行预测时，将“再缩放”（rescaling）嵌入到过程中，称为“阈值移动”（threshold-moving）；</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/23/《机器学习》笔记-模型评估与选择（2）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liu Caiquan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="才权的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/01/23/《机器学习》笔记-模型评估与选择（2）/" itemprop="url">
                  《机器学习》笔记-模型评估与选择（2）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-23T09:05:17+08:00">
                2018-01-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>由于图片外链被禁止了，图片不能显示，完整文章看这里吧：<a href="https://zhuanlan.zhihu.com/p/33199938" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/33199938</a></p>
<h1 id="写在最前面"><a href="#写在最前面" class="headerlink" title="写在最前面"></a>写在最前面</h1><p>如今机器学习和深度学习如此火热，相信很多像我一样的普通程序猿或者还在大学校园中的同学，一定也想参与其中。不管是出于好奇，还是自身充电，跟上潮流，我觉得都值得试一试。对于自己，经历了一段时间的系统学习（参考<a href="https://zhuanlan.zhihu.com/p/30980999" target="_blank" rel="external">《机器学习/深度学习入门资料汇总》</a>），现在计划重新阅读《机器学习》[周志华]和《深度学习》[Goodfellow et al]这两本书，并在阅读的过程中进行记录和总结。这两本是机器学习和深度学习的入门经典。笔记中除了会对书中核心及重点内容进行记录，同时，也会增加自己的理解，包括过程中的疑问，并尽量的和实际的工程应用和现实场景进行结合，使得知识不只是停留在理论层面，而是能够更好的指导实践。记录笔记，一方面，是对自己先前学习过程的总结和补充。 另一方面，相信这个系列学习过程的记录，也能为像我一样入门机器学习和深度学习同学作为学习参考。</p>
<h1 id="章节目录"><a href="#章节目录" class="headerlink" title="章节目录"></a>章节目录</h1><ul>
<li>经验误差与过拟合</li>
<li>评估方法</li>
<li>性能度量</li>
<li>比较检验</li>
<li>偏差与方差</li>
</ul>
<p>个人觉得对于初学的同学，一开始便谈论模型评估和选择可能不太合适。建议这个章节可以快速阅读，有大概的轮廓和线条即可。随着后面的学习，对机器学习有了初步的概念之后，再回过头来看着部分，深入其中的细节。</p>
<h2 id="（一）经验误差和过拟合"><a href="#（一）经验误差和过拟合" class="headerlink" title="（一）经验误差和过拟合"></a>（一）经验误差和过拟合</h2><p>我们把学习器的实际预测输出与样本的真实输出之间的差异称为[误差]，学习器在训练集上的误差称为[训练误差]或[经验误差]，在新样本上的误差称为[泛化误差]。</p>
<p>我们希望获得在新样本上能表现的很好的学习器。为了达到这个目的，应该从训练样本中尽可能学出适用于所有潜在样本的“普遍规律”，这样才能在遇到新样本时做出正确的判断。然而，当学习器把训练样本学得“太好”了的时候，很可能已经把训练样本自身的一些特点当做了所有潜在样本都会具有的一般性质，这样就会导致泛化性能下降。这种现象在机器学习中“过拟合”。与“过拟合”相对的是“欠拟合”，这是指对训练样本的一般性质尚未学好。</p>
<h2 id="（二）评估方法"><a href="#（二）评估方法" class="headerlink" title="（二）评估方法"></a>（二）评估方法</h2><p>通常，我们可以通过实验测试来对学习器的[泛化误差]进行评估，并进而做出选择。</p>
<p>我们假设测试样本是从样本真实分布中[独立同分布]采样而来。</p>
<p>假设我们目前有数据集D，为了满足训练和测试的需求，我们对D进行适当的处理，从中产生出训练集S和测试集T。下面介绍几种从数据集D中产生训练集S和测试集T的方法。</p>
<h3 id="1-留出法"><a href="#1-留出法" class="headerlink" title="1. 留出法"></a>1. 留出法</h3><p>留出法的步骤相对简单，直接将数据集D划分为两个互斥的集合，其中一个集合作为训练集S，另一个作为测试T。在S上训练出模型后，用T来评估测试误差，作为泛化误差的估计。训练/测试集的划分要尽可能保持数据分布的一致性，避免因数据划分过程引入额外偏差而对最终结果产生影响。</p>
<p>留出法的一个缺点是，训练集S与测试集T的划分比例不好确定。若令训练集S包含绝大多数样本，则训练出的模型可能更接近与用D训练出的模型，但由于T比较小，评估结果可能不够稳定准确；若令测试集T多包含一些样本，则训练集S与D差别更大了，被评估的模型与用D训练出的模型相比可能有较大差别，从而降低了评估结果的保真性。</p>
<h3 id="2-交叉验证法"><a href="#2-交叉验证法" class="headerlink" title="2. 交叉验证法"></a>2. 交叉验证法</h3><p>“交叉验证法”先将数据集D划分为k个大小相似的互斥子集。然后，每次用k-1个子集的并集作为训练集，余下的那个子集作为测试集，如下图所示，<br><img src="http://upload-images.jianshu.io/upload_images/4905018-e9cd953dbd646c04.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="10折交叉验证示意图"><br>交叉检验中的“留一法”使用的训练集与初始化数据集相比只少了一个样本，这就使得在绝大多数情况下，留一法中被实际评估的模型与期望评估的用D训练出的模型很相似。因此，留一法的评估结果往往被认为比较准确。然而，留一法也有其缺陷：在数据集比较大时，训练的计算开销可能难以忍受。另外，留一法的评估结果也未必永远比其他评估方法准确。</p>
<h3 id="3-自助法"><a href="#3-自助法" class="headerlink" title="3.自助法"></a>3.自助法</h3><p>我们希望评估的是用D训练出的模型。但在留出法和交叉验证法中，由于保留了一部分样本用于测试，因此实际评估的模型所使用的训练集比D小，这必然会引入一些因训练样本规模不同而导致估计偏差。留一法受训练样本规模影响较小，但计算复杂度又太高了。有没有什么办法可以减少训练样本规模不同造成的影响，同时还能比较高效进行试验评估呢？</p>
<p>“自助法”是一个比较好的解决方案。给定包含m个样本的数据集D，我们对它进行采样产生数据集D’：每次随机从D中挑选一个样本，并将其拷贝放入D’中，然后再将该样本放回数据集D中，使得该样本在下次采样时仍有可能被采到；这个过程重复执行m次后，我们得到了包含m个样本的数据集D’，这就是我们自助采样的结果。我们将D’作为训练集，将D-D‘（集合减法）作为测试集。</p>
<p>自助法在数据集较小、难以有效划分训练/测试集时很有用；此外，自助法能从初始数据集中产生多个不同的训练集，这对集成学习等方法有很大的好处。然而，自助法产生的数据改变了初始数据集的分布，这会引入估计偏差。因此，在初始数据量足够是，留出法和交叉验证法更常用一些。</p>
<h2 id="（三）性能度量"><a href="#（三）性能度量" class="headerlink" title="（三）性能度量"></a>（三）性能度量</h2><p>在预测任务中，给定样本集<br><img src="http://upload-images.jianshu.io/upload_images/4905018-76342efb3fe11d17.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="样本集"><br>其中，yi是示例xi的真实标记。</p>
<p>回归任务中最常用的性能度量是[均方误差]，<br><img src="http://upload-images.jianshu.io/upload_images/4905018-7a780b039b372817.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="均方误差"></p>
<h3 id="1-错误率与精度"><a href="#1-错误率与精度" class="headerlink" title="1. 错误率与精度"></a>1. 错误率与精度</h3><p>错误率和精度是分类任务中最常用的两种性能量度。<br>错误率是分类错误的样本占样本总数的比例，<br><img src="http://upload-images.jianshu.io/upload_images/4905018-b294b0877bc8dce2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="错误率"><br>精度则是分类正确的样本占样本总数的比例，<br><img src="http://upload-images.jianshu.io/upload_images/4905018-52505d3e95d0acb3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="精度"></p>
<h3 id="2-查准率、查全率与F1"><a href="#2-查准率、查全率与F1" class="headerlink" title="2.查准率、查全率与F1"></a>2.查准率、查全率与F1</h3><p>对应西瓜问题，如果我们关心的是“挑出的瓜有多少是好瓜？”或者“所有好瓜中有多少比例被调出来了？”，那么错误率显然就不够用了。[查准率]和[查全率]则更适用于此类需求的性能度量。</p>
<p>对二分类问题，可将样例根据其实际类别与学习器预测类别的组合划分为真正例（true positive，TP）、假正例（false positive，FP）、真反例（true negative，TN）、假反例（false negative，FN）四种情况，如下图所示，<br><img src="http://upload-images.jianshu.io/upload_images/4905018-ddcc265476425f78.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="分解结构混淆矩阵"><br>查准率P与查全率R分别定义为，<br><img src="http://upload-images.jianshu.io/upload_images/4905018-e2bb0d3e8070aae5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="查准率，查全率"><br>以查准率作为纵轴，查全率作为横轴作图，就得到了[查准率]-[查全率]曲线，简称”P-R曲线”，<br><img src="http://upload-images.jianshu.io/upload_images/4905018-bdcd3c37fbc5857f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="P-R曲线"></p>
<p>查准率和查全率是一对矛盾的度量。人们设计了一些综合考虑查准率、查全率的性能度量。[平衡点]（Break-Even Point，简称BEP）就是这样一个度量，它是[查准率]=[查全率]时的取值。</p>
<p>BEP过于简化，更常用的的是F1度量，<br><img src="http://upload-images.jianshu.io/upload_images/4905018-faae3f1e52a29293.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="F1度量"><br>在一些应用中，对查准率和查全率的重视程度有所不同。从而有了F1度量的一般形式，<br><img src="http://upload-images.jianshu.io/upload_images/4905018-133fd928e0291e37.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="F1一般形式"><br>系数β&gt;1时查全率有更大影响；β&lt;1时，查准率有更大影响。</p>
<p>很多时候我们有多个二分类混淆矩阵，我们希望在n个二分类混淆矩阵上综合考察查准率和查全率。目前有两种方法：</p>
<ul>
<li>”宏查准率(macro-P)“、”宏查全率(macro-R)“、及相应的宏F1(macro-F1)</li>
<li>”微查准率(micro-P)“、”微查全率(micro-R)“、及相应的微F1(micro-F1）</li>
</ul>
<h3 id="3-ROC与AUC"><a href="#3-ROC与AUC" class="headerlink" title="3.ROC与AUC"></a>3.ROC与AUC</h3><p>很多学习器是为测试样本产生一个实值或概率预测，然后将这个预测值与一个分类阈值进行比较，若大于阈值则分为正类，否则为反类。在不同的应用任务中，我们可根据任务需求（如若我们可以依据更重视[查准率]或更重视[查全率]）来选择不同的阈值。ROC曲线便是从这个角度出发来研究学习器泛化性能的有力工具。<br>与P-R曲线使用查准率、查全率为横纵轴不同，ROC的纵轴是”真正样例（True Positive Rate，简称TPR）”，横轴是“假正例率（False Positive Rate，简称FPR），两者分别定义为，<br><img src="http://upload-images.jianshu.io/upload_images/4905018-b1fb5b4014b7edbc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TPR，FPR"><br>显示ROC的曲线图称为“ROC图”，<br><img src="http://upload-images.jianshu.io/upload_images/4905018-df9565e50682df57.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ROC曲线与AUC示意图"><br>进行学习器比较时，与P-R如相似，若一个学习器的ROC曲线被另一个学习器的曲线“包住”，则可断言后者的性能优于前者；若两个学习器的ROC曲线发生交叉，则难以一般性的断言两者孰优孰劣。此时如果一定要进行比较，则较为合理的判断是比较ROC曲线下的面积，即AUC（Area Under ROC Curve）。</p>
<h3 id="4-代价敏感错误率与代价曲线"><a href="#4-代价敏感错误率与代价曲线" class="headerlink" title="4. 代价敏感错误率与代价曲线"></a>4. 代价敏感错误率与代价曲线</h3><p>在现实任务中会遇到这样的情况：不同类型错误所造成的后果不同。例如在医疗诊断中，错误的把患者诊断为健康人与错误的把健康人诊断为患者，看起来都是犯了“一次错误”，但后者的影响是增加了进一步检查的麻烦，前者的后果却可能是丧失拯救生命的最好时机。<br>以二分类任务为例，我们可根据任务领域知识设定一个“代价矩阵”，如下图所示，<br><img src="http://upload-images.jianshu.io/upload_images/4905018-1796bd7d400e8f3d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="二分类代价矩阵"><br>在非均等代价下，ROC曲线不能直接反映出学习器的期望总体代价，而“代价曲线（cost curve）”则可达到目的。代价曲线图的横轴是取值为[0，1]的正例概率代价，<br><img src="http://upload-images.jianshu.io/upload_images/4905018-35a531c1d274acfc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="正例概率代价"><br>纵轴是取值为[0，1]的归一化代价，<br><img src="http://upload-images.jianshu.io/upload_images/4905018-1aab0d4bb61351b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="归一化代价"><br>画图表示如下图所示，<br><img src="http://upload-images.jianshu.io/upload_images/4905018-d79d07d4bd3a065c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="代价曲线与期望总体代价"></p>
<h2 id="（四）比较检验"><a href="#（四）比较检验" class="headerlink" title="（四）比较检验"></a>（四）比较检验</h2><p>统计假设检验为我们进行学习器性能比较提供了重要依据。基于假设检验结果我们可以推测，若在测试集上观察到学习器A比B好，则A的泛化性能是否在统计意义上优于B，以及这个结论的把握有多大。</p>
<h3 id="1-假设检验"><a href="#1-假设检验" class="headerlink" title="1. 假设检验"></a>1. 假设检验</h3><p>假设检验中的“假设”是对学习器泛化错误率分布的某种判断或猜想。<br>对于错误率，我们可以采用“二项检验”来计算“置信度”。<br>很多时候，我们并非仅做一次留出法估计，而是通过多次重复留出法或是交叉验证法等进行多次训练/测试，这样会得到多个测试错误率，此时，可使用“t检验”。</p>
<h3 id="2-交叉验证t检验"><a href="#2-交叉验证t检验" class="headerlink" title="2. 交叉验证t检验"></a>2. 交叉验证t检验</h3><p>上面介绍的“二项检验”和“t检验”都是对关于单个学习器泛化性能的假设进行检验，而现实任务中，更多的时候我们需对不同学习器的性能进行比较。<br>对两个学习器A和B，若我们使用”k折交叉验证法”，则可用“成对t检验”（paired t-tests）来进行比较检验。<br>对于二分类问题，使用“留出法”估计学习器A和B的测试误差，可采用McNemar检验。</p>
<h3 id="3-Friedman检验与Nemenyi后续检验"><a href="#3-Friedman检验与Nemenyi后续检验" class="headerlink" title="3. Friedman检验与Nemenyi后续检验"></a>3. Friedman检验与Nemenyi后续检验</h3><p>交叉验证t检验和McNemar检验都是在一个数据上比较两个算法的性能，而很多时候，我们会在一组数据集上对多个算法进行比较。当有多个算法参与比较时，一种做法是在每个数据集上分别列出两两比较的结果，而在两两比较时可使用前述方法；另一种方法更为直接，即使用使用基于算法排序的Friedman检验。<br>使用Friedman检验判断这些算法是否性能都相同。若“所有算法性能都相同”这个假设被拒绝，则说明算法的性能显著不同。这时需要进行“后续检验”（post-hoc test）来进一步区分各算法。常用的有Nemenyi后续检验。</p>
<h2 id="（五）偏差与方差"><a href="#（五）偏差与方差" class="headerlink" title="（五）偏差与方差"></a>（五）偏差与方差</h2><p>对学习算法除了通过实验估计器泛化性能，人们往往还希望了解它“为什么”具有这样的性能。“偏差-方差分解”（bias-variance decomposition）是解释学习算法泛化性能的一种重要工具。<br>泛化误差可分解为偏差、方差和噪声。<br><img src="http://upload-images.jianshu.io/upload_images/4905018-8c38c5b4bc50f5ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="泛化误差"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/19/树莓派平台移植DLNA库（Platinum-UPnP）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liu Caiquan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="才权的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/01/19/树莓派平台移植DLNA库（Platinum-UPnP）/" itemprop="url">
                  树莓派平台移植DLNA库（Platinum UPnP）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-19T16:17:09+08:00">
                2018-01-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>由于图片外链被禁止了，图片不能显示，完整文章看这里吧：<a href="https://www.jianshu.com/p/11eb4aa2359e" target="_blank" rel="external">https://www.jianshu.com/p/11eb4aa2359e</a></p>
<h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>DLNA 成立于2003 年6 月24 日,  其前身是DHWG （Digital Home Working Group 数字家庭工作组），由Sony、Intel、Microsoft等发起成立、旨在解决个人PC ，消费电器，移动设备在内的无线网络和有线网络的互联互通，使得数字媒体和内容服务的无限制的共享和增长成为可能。官方网址：<a href="https://www.dlna.org/。" target="_blank" rel="external">https://www.dlna.org/。</a></p>
<p>2017年2月，DLNA委员会昨日正式对外宣布，该组织已于今年1月5日正式解散，并表示该组织解散的原因是旧的标准已经无法满足新设备的发展趋势，DLNA标准将来也不会再更新。DLNA委员会解散后，设备的认证和测试等工作将由DLNA高管在美国波特兰成立的SpireSpark公司接管，新的负责组织将在新的费用结构下，做包括HTML5在内的DLNA的DRM和认证。</p>
<h2 id="设备组成"><a href="#设备组成" class="headerlink" title="设备组成"></a>设备组成</h2><p>Home NetWork Device(HND)，这类设备指家庭设备，具有比较大的尺寸及较全面的功能，主要与移动设备区别开来，下属5类设备：</p>
<ul>
<li>DMS（Digital Media Server)<br>数字媒体服务器，提供媒体获取、记录、存储和输出功能。同时，内容保护功能是对DMS的强制要求。DMS总是包含DMP的功能，并且肯能包含其他智能功能，包括设备/用户服务的管理；丰富的用户界面；媒体管理/收集和分发功能。DMS的例子有PC、数字机顶盒（附带联网，存储功能）和摄像机等等。</li>
<li>DMP<br>数字媒体播放器。能从DMS/M-DMS上查找并获取媒体内容并播放和渲染显示。比如智能电视、家庭影院等</li>
<li>DMC<br>数字媒体控制器，查找DMS的内容并建立DMS与DMR之间的连接并控制媒体的播放。如遥控器。</li>
<li>DMR<br>数字媒体渲染设备。通过其他设备配置后，可以播放从DMS上的内容。与DMP的区别在于DMR只有接受媒体和播放功能，而没查找有浏览媒体的功能。比如显示器、音箱等。</li>
<li>DMPr<br>数字媒体打印机，提供打印服务。网络打印机，一体化打印机就属于DMPr。</li>
</ul>
<h2 id="DLNA-SDK选择"><a href="#DLNA-SDK选择" class="headerlink" title="DLNA SDK选择"></a>DLNA SDK选择</h2><p>目前主流的DLNA SDK可以在OFC（Open Connectivity Foundation）官网上查询（<a href="https://openconnectivity.org/developer/specifications/upnp-resources/upnp-developer-resources#sdks）" target="_blank" rel="external">https://openconnectivity.org/developer/specifications/upnp-resources/upnp-developer-resources#sdks）</a></p>
<p><img src="http://upload-images.jianshu.io/upload_images/4905018-3eb1b5067145ace6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="主流DLNA SDK"></p>
<p>树莓派平台的验证测试采用了Platinum UPnP，官方网址：<a href="http://www.plutinosoft.com/platinum。" target="_blank" rel="external">http://www.plutinosoft.com/platinum。</a></p>
<p>选择Platinum UPnP主要出于如下考虑：</p>
<ul>
<li>使用广泛<br>目前已有较多的产品基于该SDK进行DLNA功能开发；</li>
<li>跨平台<br>采用C++编写，集成Neptune C++运行库。同时，编译框架也做了跨平台考虑，默认支持Linux、windows、Android等平台；</li>
<li>代码开源<br>代码完全开源；</li>
<li>示例丰富<br>内置FileMediaServerTest，MediaRendererTest等丰富参考样例，方便开发参考；</li>
</ul>
<p>需要注意的是Platinum UPnP针对企业用户和开发者用户采用GPL和商用许可证两个license，<br><img src="http://upload-images.jianshu.io/upload_images/4905018-bbf65bc0f7d69986.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="双许可证"></p>
<h2 id="树莓派平台移植Platinum-UPnP"><a href="#树莓派平台移植Platinum-UPnP" class="headerlink" title="树莓派平台移植Platinum UPnP"></a>树莓派平台移植Platinum UPnP</h2><p>下面将通过集成Platinum UPnP，使树莓派具备DMR功能，能够被DMS设备（如手机上的百度音乐App）发现，并接收来自DMS设备推送的资源URI，及播放状态信息。</p>
<h3 id="安装cons"><a href="#安装cons" class="headerlink" title="安装cons"></a>安装cons</h3><p>Platinum UPnP基于scons进行编译，所以，首先要安装scons。安装过程可以参考<a href="http://blog.csdn.net/djy37010/article/details/51312975" target="_blank" rel="external">《ubuntu下安装SCons》</a></p>
<h3 id="Platinum-UPnP下载"><a href="#Platinum-UPnP下载" class="headerlink" title="Platinum UPnP下载"></a>Platinum UPnP下载</h3><pre><code># git clone https://github.com/plutinosoft/Platinum.git
</code></pre><h3 id="更新依赖"><a href="#更新依赖" class="headerlink" title="更新依赖"></a>更新依赖</h3><p>Platinum UPnP依赖Neptune，</p>
<pre><code># cd Platinum
# git submodule update --init
</code></pre><h3 id="增加树莓派平台支持"><a href="#增加树莓派平台支持" class="headerlink" title="增加树莓派平台支持"></a>增加树莓派平台支持</h3><p>默认Platinum UPnP并不支持树莓派平台，需要我们手动添加。</p>
<p>####1. 添加树莓派平台目标目录<br>在Platinum/Build/Targets目录添加arm-raspberry-linux目录</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4905018-63f5fab7968c08f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="添加树莓派平台目录"></p>
<h4 id="2-添加树莓派平台交叉编译配置文件"><a href="#2-添加树莓派平台交叉编译配置文件" class="headerlink" title="2. 添加树莓派平台交叉编译配置文件"></a>2. 添加树莓派平台交叉编译配置文件</h4><p>在Platinum/Build/Targets/arm-raspberry-linux目录下添加Config.scons文件，文件内容如下，<br><img src="http://upload-images.jianshu.io/upload_images/4905018-83de3f3248a5cd0c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="交叉编译配置文件"></p>
<h3 id="增加MDR打印信息"><a href="#增加MDR打印信息" class="headerlink" title="增加MDR打印信息"></a>增加MDR打印信息</h3><p>修改Platinum/Source/Devices/MediaRenderer/PltMediaRenderer.cpp文件，<br><img src="http://upload-images.jianshu.io/upload_images/4905018-964cc7b291ef7d2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="增加MDR打印信息"></p>
<h3 id="编译输出"><a href="#编译输出" class="headerlink" title="编译输出"></a>编译输出</h3><p>在Platinum目录运行，</p>
<pre><code># scons target=arm-raspberry-linux build_config=Debug
</code></pre><p>编译生成的应用程序在Platinum/Targets/arm-raspberry-linux/Debug目录下，<br><img src="http://upload-images.jianshu.io/upload_images/4905018-a1cb1c77e2aa218e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="生成应用程序"></p>
<p>编译生成的静态库在Platinum/Build/Targets/arm-raspberry-linux/Debug目录下，<br><img src="http://upload-images.jianshu.io/upload_images/4905018-2d08b5d78fc69c61.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="生成静态库"></p>
<h3 id="测试验证"><a href="#测试验证" class="headerlink" title="测试验证"></a>测试验证</h3><p>树莓派和安装百度音乐的手机处于同一局域网内，在树莓派端运行MediaRenderTest，启动树莓派端的DMR能力。</p>
<pre><code># ./MediaRendererTest -f eddy-raspberry
</code></pre><h4 id="1-百度音乐-DMS-发现树莓派-DMR-设备"><a href="#1-百度音乐-DMS-发现树莓派-DMR-设备" class="headerlink" title="1.百度音乐[DMS]发现树莓派[DMR]设备"></a>1.百度音乐[DMS]发现树莓派[DMR]设备</h4><p><img src="http://upload-images.jianshu.io/upload_images/4905018-e1f4beb91f957047.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="MDS"></p>
<h4 id="2-树莓派-DMR-接收来自百度音乐-DMS-的信息"><a href="#2-树莓派-DMR-接收来自百度音乐-DMS-的信息" class="headerlink" title="2.树莓派[DMR]接收来自百度音乐[DMS]的信息"></a>2.树莓派[DMR]接收来自百度音乐[DMS]的信息</h4><p><img src="http://upload-images.jianshu.io/upload_images/4905018-cfaf64928b35a289.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="MDR"></p>
<h2 id="资料参考："><a href="#资料参考：" class="headerlink" title="资料参考："></a>资料参考：</h2><p><a href="http://blog.csdn.net/lancees/article/details/8230877" target="_blank" rel="external">《DLNA介绍》</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/19/《机器学习》笔记-绪论（1）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liu Caiquan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="才权的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/01/19/《机器学习》笔记-绪论（1）/" itemprop="url">
                  《机器学习》笔记-绪论（1）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-19T10:14:58+08:00">
                2018-01-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>由于图片外链被禁止了，图片不能显示，完整文章看这里吧：<a href="https://zhuanlan.zhihu.com/p/33089702" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/33089702</a></p>
<h1 id="写在最前面"><a href="#写在最前面" class="headerlink" title="写在最前面"></a>写在最前面</h1><p>如今机器学习和深度学习如此火热，相信很多像我一样的普通程序猿或者还在大学校园中的同学，一定也想参与其中。不管是出于好奇，还是自身充电，跟上潮流，我觉得都值得试一试。对于自己，经历了一段时间的系统学习（参考<a href="https://zhuanlan.zhihu.com/p/30980999" target="_blank" rel="external">《机器学习/深度学习入门资料汇总》</a>），现在计划重新阅读《机器学习》[周志华]和《深度学习》[Goodfellow et al]这两本书，并在阅读的过程中进行记录和总结。这两本是机器学习和深度学习的入门经典。笔记中除了对书中核心及重点内容进行记录，同时，也会增加自己的理解，包括过程中的疑问，并尽量的和实际的工程应用和现实场景进行结合，使得知识不只是停留在理论层面，而是能够更好的指导实践。记录笔记，一方面，对于自己，是对先前学习过程的总结和补充。 另一方面，相信这个系列学习过程的记录，也能为像我一样入门机器学习和深度学习同学作为学习参考。</p>
<h1 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h1><p>在学习过程中，最让人觉得枯燥的内容之一便是[术语]了。[术语]对内容或原理做了抽象和概括，所以开始的时候不容易接受，并且容易混淆。但术语又很神奇，掌握了术语后，发现对很多复杂的原理或流程进行表述变得容易。最重要的是，当自己能够自如的听懂术语并使用术语时，自己也不知不觉的从“外行”变成了“内行”（脑补《智取威虎山》的场景：“天王盖地虎”，“宝塔镇河妖”）。下面我们会实际的场景出发，这样术语的理解和消化也会变的容易。</p>
<p>《机器学习》这本书的封面是一堆西瓜，而书中的大多数方法和模型也是以西瓜的例子进行展开和分析的。这个西瓜的例子很简单，就是给你一堆西瓜的已知特征如（色泽、根蒂、敲声），来判断西瓜的未知特性，如是否成熟或成熟程度。</p>
<ul>
<li>数据集<br>西瓜的已知特性集合（如色泽、根蒂、敲声，以及是否成熟或成熟程度）；</li>
<li>特征向量<br>把数据集中的特征用向量表示；</li>
<li>维数<br>特征的个数；</li>
<li>分类<br>判断好瓜还是坏瓜（离散值）；</li>
<li>回归<br>判断成熟程度（连续值，如成熟度为0.98）；</li>
<li>聚类<br>将西瓜自动分为“本地瓜”，“外地瓜”（“本地瓜”和“外地瓜”这些概念我们事前是不知道的）；</li>
<li>监督学习<br>训练数据有标记信息（如分类、回归）</li>
<li>无监督学习<br>训练数据没有标记信息（如聚类）</li>
<li>独立同分布<br>假设样本空间中全部个体样本都服从一个未知的分布，同时，每个样本都是独立的从这个分布上采样获得的；</li>
</ul>
<h1 id="归纳偏好"><a href="#归纳偏好" class="headerlink" title="归纳偏好"></a>归纳偏好</h1><p>任何一个有效的机器学习算法必有其归纳偏好，否则它将被假设空间中看似在训练集上的等效假设所迷惑，而无法产生确定的学习结果。</p>
<p>归纳偏好的一个一般性原则便是“奥卡姆剃刀”。它是一种常用的、自然科学中最基本的原则，即“若有多个假设与观察一直，则选最简单的那个”</p>
<p>“没有免费午餐”定理（No Free Lunch Theorem，简称NFL定理）说明所有的学习算法的期望性能是相同的。我们只关注自己正在解决的问题，希望为它找到一个解决方案，至于这个解决方案在别的问题、甚至在相似的问题上是否为好方案，我们并不关心。脱离具体问题，空泛谈论“什么学习算法更好”毫无意义。</p>
<h1 id="发展历程"><a href="#发展历程" class="headerlink" title="发展历程"></a>发展历程</h1><p>主流技术演进：</p>
<ul>
<li>二十世纪八十年代-符号主义学习<br>代表包括决策树和基于逻辑的学习。但由于学习过程面临的假设空间太大、复杂度极高，因此，问题规模稍大就难以有效进行学习，九十年代中期后这方面的研究相对陷入低潮；</li>
<li>二十世纪九十年代中期之前-基于神经网络的连接学习<br>连接主义在二十世纪五十年代取得了大发展，同时也遇到了很大的障碍，如图灵得主M.Minsky和S.Papert在1969年指出，（当时的）神经网络只能处理线性分类，甚至对“异或”这么简单的问题都处理不了。1983年，J.J Hopfield利用神经网络求解“流动推销员问题”这个著名的NP难题取得重大进展，使得连接注意重新受到人们关注。1986年，D.E. Rumelhart等人重新发明了著名的BP（反向传播）算法，产生了深远影响。神经网络学习过程涉及大量参数，而参数的设置缺乏理论指导，主要靠手工“调参”；夸张一点说，参数调节上失之毫厘，学习结果可能谬以千里。</li>
<li>二十世纪九十年代中期-统计学习<br>代表性技术是支持向量机以及更一般的核方法。这方面的研究早在二十世纪六七十年代就已开始。统计学习与连接主义学习有密切的联系。支持向量机被普遍接受后，核技巧（kernel rick）被人们用到了机器学习的几乎每个角落，核方法也逐渐成为机器学习的基本内容之一。</li>
<li>二十一世纪初-深度学习<br>深度学习，狭义的说就是“很多层”的神经网络。深度学习虽然缺乏严格的理论基础，但它显著的降低了机器学习应用者的门槛，为机器学习技术走向工程实践带来了便利。深度学习火热有两个基本原因：数据大了、计算能力强了。深度学习模型拥有大量数据，若数据样本少，则很容易“过拟合”；如此复杂的模型，如此大的数据样本，若缺乏强力计算设备，根本无法求解。</li>
</ul>
<p>事实上，图灵在1950年关于图灵测试的文章中，就曾提到了机器学习的可能。二十世纪五十年代初已有机器学习的相关研究。五十年代中后期基于神经网络的“连接主义”学习开始出现。在六七十年代，基于逻辑表示的“符号主义”学习技术蓬勃发展。以决策理论为基础的学习以及强化学习技术等也得到发展。二十多年后红极一时的统计学习理论的一些奠基性结果也是在这个时期获得的。</p>
<h1 id="应用现状"><a href="#应用现状" class="headerlink" title="应用现状"></a>应用现状</h1><p>大数据时代三大关键技术：机器学习、云计算、众包（ImageNet的数据标记便采用了众包形式）；</p>
<p>机器学习领域和数据库领域是数据挖掘的两大支撑；</p>
<p>2004年3月，在美国DARPA组织的自动驾驶车比赛中，斯坦福大学机器学习专家小组研制的参赛车获得冠军（无人驾驶很早就起步了）。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/11/TensorFlow开发环境搭建（Ubuntu16-04-GPU-TensorFlow源码编译）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liu Caiquan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="才权的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/01/11/TensorFlow开发环境搭建（Ubuntu16-04-GPU-TensorFlow源码编译）/" itemprop="url">
                  TensorFlow开发环境搭建（Ubuntu16.04+GPU+TensorFlow源码编译）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-11T20:47:36+08:00">
                2018-01-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>由于图片外链被禁止了，图片不能显示，完整文章看这里吧：<a href="https://zhuanlan.zhihu.com/p/33089119" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/33089119</a></p>
<h1 id="1-安装选择"><a href="#1-安装选择" class="headerlink" title="1 安装选择"></a>1 安装选择</h1><h2 id="1-1-平台"><a href="#1-1-平台" class="headerlink" title="1.1 平台"></a>1.1 平台</h2><p>目前TensorFlow已支持Mac、Ubuntu和Windows三个主流平台（64位平台），<br><img src="http://upload-images.jianshu.io/upload_images/4905018-d562d05d81808e9b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="https://www.tensorflow.org/install/"></p>
<h2 id="1-2-GPU-vs-CPU"><a href="#1-2-GPU-vs-CPU" class="headerlink" title="1.2 GPU vs CPU"></a>1.2 GPU vs CPU</h2><p>在安装时可以选择安装版本是否支持GPU，<br><img src="http://upload-images.jianshu.io/upload_images/4905018-63dce636960a5e42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="https://www.tensorflow.org/install/install_linux"></p>
<h2 id="1-3-二进制安装-vs-源码安装"><a href="#1-3-二进制安装-vs-源码安装" class="headerlink" title="1.3 二进制安装 vs 源码安装"></a>1.3 二进制安装 vs 源码安装</h2><p>同时，安装时可以考虑采用二进制安装，还是源码安装，<br><img src="http://upload-images.jianshu.io/upload_images/4905018-caff1336d1dd1238.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="https://www.tensorflow.org/install/"></p>
<h2 id="1-4-二进制安装选择"><a href="#1-4-二进制安装选择" class="headerlink" title="1.4 二进制安装选择"></a>1.4 二进制安装选择</h2><p>二进制安装可以有多种选择，<br><img src="http://upload-images.jianshu.io/upload_images/4905018-6d617b3d2e736011.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="https://www.tensorflow.org/install/install_linux"></p>
<h2 id="1-5-实际使用选择"><a href="#1-5-实际使用选择" class="headerlink" title="1.5 实际使用选择"></a>1.5 实际使用选择</h2><p>手头上有两台电脑，</p>
<ul>
<li>MacBook Pro (Retina, 13-inch, Early 2015)<br>处理器：2.7 GHz Intel Core i5<br>内存：8GB 1867MHz DDR3<br>显卡：Intel Iris Graphics 6100 1536MB</li>
<li>攀升兄弟组装台式机<br>处理器：英特尔 Core i7-6700 @3.40GHz 四核<br>主板：华硕 B150M-ET M2 SERIES<br>内存：8G（威刚DDR4 2801MHz）<br>硬盘：三星 MZ7TE256HMHP-00000（256GB/固态硬盘）<br>显卡：Nvidia GeForce GTX 950(2GB)</li>
</ul>
<p>其中，<br>MacBook Pro采用基于Anaconda的二进制安装方式（仅支持CPU）。Anaconda是一个集成平台，包含大多数机器学习的常用工具，</p>
<ul>
<li>NumPy：科学运算包</li>
<li>SciPy：在NumPy的基础上构建，功能更加强大的科学计算包</li>
<li>Matplotlib：类似Matlab的绘图工具包</li>
<li>Scikit-learn：经典机器学习工具包</li>
<li>Pandas：数据处理和分析工具包（可用于数据读写、清洗、填充和分析等场景）<br>采用Anaconda安装方案，一方面MacBook Pro的开发环境很容易搭建（几句命令即可完成），另一方面，基于Anaconda的环境，也可以方便验证简单的机器学习算法。</li>
</ul>
<p>对于台式机则采用了Ubuntu+GPU+TensorFlow源码编译的方式，进行TensorFlow环境搭建，下面我们着重介绍下这种安装方式。</p>
<h1 id="2-Ubuntu16-04-TensorFlow-GPU-源码编译"><a href="#2-Ubuntu16-04-TensorFlow-GPU-源码编译" class="headerlink" title="2 Ubuntu16.04+TensorFlow(GPU)源码编译"></a>2 Ubuntu16.04+TensorFlow(GPU)源码编译</h1><h2 id="2-1-Ubuntu系统安装"><a href="#2-1-Ubuntu系统安装" class="headerlink" title="2.1 Ubuntu系统安装"></a>2.1 Ubuntu系统安装</h2><p>目前，大多数计算机，包括台式机已没有了光驱，同时，Ubuntu的系统安装盘也不易获得。针对这种情况，我们可以采用U盘来进行安装。具体步骤可以参考：<a href="http://www.linuxidc.com/Linux/2016-04/130520.htm" target="_blank" rel="external">《Ubuntu 16.04 U盘安装图文教程》</a></p>
<h2 id="2-2-禁用UEFI安全启动"><a href="#2-2-禁用UEFI安全启动" class="headerlink" title="2.2 禁用UEFI安全启动"></a>2.2 禁用UEFI安全启动</h2><p>对于华硕 B150M-ET主板，UEFI默认是开启的。而UEFI开启会导致第三方驱动安装失败（如显卡驱动，这是源码编译安装GPU支持的TensorFlow，遇到的第一个坑）。具体步骤可以参考：<a href="https://www.cnblogs.com/zhaofenqiang/p/6071385.html?utm_source=itdadao&amp;utm_medium=referral" target="_blank" rel="external">《华硕主板禁用UEFI安全启动》</a></p>
<h2 id="2-3-安装NVIDIA驱动"><a href="#2-3-安装NVIDIA驱动" class="headerlink" title="2.3 安装NVIDIA驱动"></a>2.3 安装NVIDIA驱动</h2><h3 id="2-3-1-安装方式"><a href="#2-3-1-安装方式" class="headerlink" title="2.3.1 安装方式"></a>2.3.1 安装方式</h3><p>英伟达的显卡驱动有三种方式：</p>
<ul>
<li>apt-get+系统设置安装</li>
<li>安装CUDA时顺便安装</li>
<li><p>官方下载最新驱动并安装<br>参考：<a href="http://blog.csdn.net/cosmoshua/article/details/76644029" target="_blank" rel="external">《Ubuntu 16.04安装NVIDIA驱动》</a></p>
<h3 id="2-3-2-安装步骤"><a href="#2-3-2-安装步骤" class="headerlink" title="2.3.2 安装步骤"></a>2.3.2 安装步骤</h3><p>本文采用第一种方案：</p>
<pre><code>sudo apt-get install nvidia-367
</code></pre></li>
</ul>
<p>然后进入：System Settings-&gt;Software&amp;Updates-&gt;Additional Drivers-&gt;，选择NVIDIA Corporation[Using NVIDIA binary driver]</p>
<h3 id="2-3-3-验证测试"><a href="#2-3-3-验证测试" class="headerlink" title="2.3.3 验证测试"></a>2.3.3 验证测试</h3><pre><code>nvidia-smi #若列出GPU的信息列表，表示驱动安装成功
nvidia-settings #若弹出设置对话框，亦表示驱动安装成功
</code></pre><h2 id="2-4-安装CUDA"><a href="#2-4-安装CUDA" class="headerlink" title="2.4 安装CUDA"></a>2.4 安装CUDA</h2><p>CUDA(Compute Unified Device Architecture)，是显卡厂商NVIDIA推出的运算平台。可以理解成基于GPU并行计算的应用层接口。<br><a href="https://developer.nvidia.com/cuda-80-download-archive" target="_blank" rel="external">CUDA8.0下载地址</a><br><img src="http://upload-images.jianshu.io/upload_images/4905018-d71f88879413fe85.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="https://developer.nvidia.com/cuda-80-download-archive"><br>安装Cuda的时候，需要关闭X服务。</p>
<pre><code>sudo service lightdm stop
</code></pre><p>这时，系统会出现黑屏。此时，同时按住[CTRL + ALT + F1]三个键进入命令行模式（如果不能进入命令行模式，可以参考<a href="http://blog.csdn.net/u010733679/article/details/52022094" target="_blank" rel="external">《alt+ctrl+F1黑屏 ，解决方案》</a>），<br>然后输入[账号]，[密码]后登陆。<br>在CUDA的下载目录运行，</p>
<pre><code>sudo sh cuda_xxx.run
</code></pre><p>需要注意的是，在询问是否安装“NVIDIA Accelerated Graphics Driver”可以选择“是”，</p>
<pre><code>Install NVIDIA Accelerated Graphics Driver for Linux-x86_64 361.62?
(y)es/(n)o/(q)uit: y
</code></pre><p>但在后续出现询问是否安装“X configuration”时，则需要选择“否”，否则之前安装的显卡驱动就白安装了。<br>CUDA安装结束后，则可以恢复到图形界面模式，</p>
<pre><code>sudo service lightdm start
</code></pre><p>到这里，CUDA的安装还不算结束，需要将CUDA相关的内容添加到系统环境变量中。安装过程中Summary提示，</p>
<pre><code>Please make sure that
– PATH includes /usr/local/cuda-8.0/bin
– LD_LIBRARY_PATH includes /usr/local/cuda-8.0/lib64, or, add /usr/local/cuda-8.0/lib64 to /etc/ld.so.conf and run ldconfig as root
</code></pre><p>CUDA相关的环境变量可以放在~/.bashrc中，</p>
<pre><code>vi ~/.bash_profile
</code></pre><p>在其中，增加如下两行，</p>
<pre><code>export LD_LIBRARY_PATH=&quot;$LD_LIBRARY_PATH:/usr/local/cuda-  8.0/lib64:/usr/local/cuda-8.0/extras/CUPTI/lib64&quot;
export CUDA_HOME=/usr/local/cuda-8.0
</code></pre><h2 id="2-5-安装cuDNN"><a href="#2-5-安装cuDNN" class="headerlink" title="2.5 安装cuDNN"></a>2.5 安装cuDNN</h2><p>cuDNN（CUDA Deep Neural Network）相比标准的cuda，它在一些常用的神经网络操作上进行了性能的优化，比如卷积，pooling，归一化，以及激活层等等。<br>下载地址：<a href="https://developer.nvidia.com/rdp/cudnn-download" target="_blank" rel="external">https://developer.nvidia.com/rdp/cudnn-download</a><br><img src="http://upload-images.jianshu.io/upload_images/4905018-1c28d7c5a2928ca9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="https://developer.nvidia.com/rdp/cudnn-download"></p>
<p>下载cuDNN后进行解压，并执行如下命令：</p>
<pre><code>sudo cp cuda/include/cudnn.h /usr/local/cuda-8.0/include
sudo cp -d cuda/lib64/libcudnn* /usr/local/cuda-8.0/lib64
sudo chmod a+r /usr/local/cuda/include/cudnn.h /usr/local/cuda-8.0/lib64/libcudnn*
</code></pre><h2 id="2-6-gcc降低版本"><a href="#2-6-gcc降低版本" class="headerlink" title="2.6 gcc降低版本"></a>2.6 gcc降低版本</h2><p>网上说cuda8.0不支持5.0以上的编译器，因此需要降级，把编译器版本降到4.9，但我看了CUDA8.0的安装手册《NVIDIA CUDA INSTALLATION GUIDE FOR<br>LINUX》，并没有发现这一条，<br><img src="http://upload-images.jianshu.io/upload_images/4905018-aee83a196d31033d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="《NVIDIA CUDA INSTALLATION GUIDE FOR
LINUX》"><br>在实际使用中，还是将GCC做了降级（PS，在安装时可以先不降级，看看是否会出问题），GCC降级方法如下，</p>
<pre><code>sudo apt-get install g++-4.9
sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-4.9 20
sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-5 10
sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-4.9 20
sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-5 10
sudo update-alternatives --install /usr/bin/cc cc /usr/bin/gcc 30
sudo update-alternatives --set cc /usr/bin/gcc
sudo update-alternatives --install /usr/bin/c++ c++ /usr/bin/g++ 30
sudo update-alternatives --set c++ /usr/bin/g++
</code></pre><h2 id="2-7-安装Bazel"><a href="#2-7-安装Bazel" class="headerlink" title="2.7 安装Bazel"></a>2.7 安装Bazel</h2><p>Bazel是一个构建工具，即一个可以运行编译和测试来组装软件的工具，跟Make、Ant、Gradle、Buck、Pants和Maven一样。TensorFlow的编译是基于Bazel完成的。<br>Bazel官方地址：<a href="https://docs.bazel.build/versions/master/install.html" target="_blank" rel="external">https://docs.bazel.build/versions/master/install.html</a><br><img src="http://upload-images.jianshu.io/upload_images/4905018-f5576ff594245afb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="https://docs.bazel.build/versions/master/install.html"></p>
<h3 id="2-7-1-安装准备"><a href="#2-7-1-安装准备" class="headerlink" title="2.7.1 安装准备"></a>2.7.1 安装准备</h3><p><img src="http://upload-images.jianshu.io/upload_images/4905018-01725f875ea14762.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="https://docs.bazel.build/versions/master/install-ubuntu.html"></p>
<h3 id="2-7-2-安装"><a href="#2-7-2-安装" class="headerlink" title="2.7.2 安装"></a>2.7.2 安装</h3><p>Bazel可以通过apt-get和下载安装两种方式完成，本文中，采用下载安装的方式实现，</p>
<pre><code>chmod +x PATH_TO_INSTALL.SH 
./PATH_TO_INSTALL.SH --user 
</code></pre><h2 id="2-8-第三方库安装"><a href="#2-8-第三方库安装" class="headerlink" title="2.8 第三方库安装"></a>2.8 第三方库安装</h2><pre><code>sudo apt-get install python-numpy swig python-dev python-wheel
sudo apt-get install libcupti-dev
sudo apt-get install git
</code></pre><h2 id="2-9-TensorFlow源码编译"><a href="#2-9-TensorFlow源码编译" class="headerlink" title="2.9 TensorFlow源码编译"></a>2.9 TensorFlow源码编译</h2><h3 id="2-9-1-下载"><a href="#2-9-1-下载" class="headerlink" title="2.9.1 下载"></a>2.9.1 下载</h3><pre><code>git clone https://github.com/tensorflow/tensorflow
</code></pre><h3 id="2-9-2-编译配置"><a href="#2-9-2-编译配置" class="headerlink" title="2.9.2 编译配置"></a>2.9.2 编译配置</h3><pre><code>cd ~/tensorflow
./configure
</code></pre><h3 id="2-9-3-编译安装"><a href="#2-9-3-编译安装" class="headerlink" title="2.9.3 编译安装"></a>2.9.3 编译安装</h3><pre><code>bazel build -c opt //tensorflow/tools/pip_package:build_pip_package
bazel build -c opt --config=cuda //tensorflow/tools/pip_package:build_pip_package
bazel-bin/tensorflow/tools/pip_package/build_pip_package /tmp/tensorflow_pkg
sudo pip install /tmp/tensorflow_pkg/tensorflow-0.10.0-cp2-none-any.whl
</code></pre><p>至此，便完成了支持GPU的TensorFlow源码编译。</p>
<h2 id="2-10-环境测试"><a href="#2-10-环境测试" class="headerlink" title="2.10 环境测试"></a>2.10 环境测试</h2><p>可以通过如下代码进行测试，</p>
<pre><code># Python
import tensorflow as tf
hello = tf.constant(&apos;Hello, TensorFlow!&apos;)
sess = tf.Session()
print(sess.run(hello))
</code></pre><p>正常测试输出，</p>
<pre><code>Hello, TensorFlow!
</code></pre><h1 id="3-资料参考"><a href="#3-资料参考" class="headerlink" title="3 资料参考"></a>3 资料参考</h1><p><a href="http://www.linuxidc.com/Linux/2016-04/130520.htm" target="_blank" rel="external">《Ubuntu 16.04 U盘安装图文教程》</a><br><a href="https://www.cnblogs.com/zhaofenqiang/p/6071385.html?utm_source=itdadao&amp;utm_medium=referral" target="_blank" rel="external">《华硕主板禁用UEFI安全启动》</a><br><a href="http://blog.csdn.net/cosmoshua/article/details/76644029" target="_blank" rel="external">《Ubuntu 16.04安装NVIDIA驱动》</a><br><a href="http://blog.csdn.net/u010733679/article/details/52022094" target="_blank" rel="external">《alt+ctrl+F1黑屏 ，解决方案》</a><br><a href="https://segmentfault.com/a/1190000008234390" target="_blank" rel="external">《Ubuntu16.04 下安装GPU版TensorFlow（包括Cuda和Cudnn）》</a><br><a href="http://blog.csdn.net/zhaoyu106/article/details/52793183" target="_blank" rel="external">《ubuntu16.04下安装TensorFlow(GPU加速)》</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Liu Caiquan" />
          <p class="site-author-name" itemprop="name">Liu Caiquan</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">70</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">11</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Liu Caiquan</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

<div>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
</div>



        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  





  





  






  





  

  

  

  

</body>
</html>
