<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta property="og:type" content="website">
<meta property="og:title" content="才权的博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="才权的博客">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="才权的博客">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title> 才权的博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?4e94c4c1ded5d320541370545af638ea";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">才权的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/29/TensorFlow-GPU开发环境搭建/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liu Caiquan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="才权的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/03/29/TensorFlow-GPU开发环境搭建/" itemprop="url">
                  TensorFlow GPU开发环境搭建
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-29T23:27:14+08:00">
                2019-03-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>由于图片外链被禁止了，图片不能显示，完整文章看这里吧：<a href="https://zhuanlan.zhihu.com/p/60924644" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/60924644</a></p>
<p>TensorFlow有CPU版本和GPU版本之分，CPU版本安装相对简单，按着TensorFlow的官方文档进行安装即可。但CPU版本只能使用CPU进行计算，计算效率低。对于简单的模型计算可以使用CPU模式，但对于复杂的模型训练就需要GPU的支持了。</p>
<h2 id="GPU版本安装方式"><a href="#GPU版本安装方式" class="headerlink" title="GPU版本安装方式"></a>GPU版本安装方式</h2><p>TensorFlow的GPU版本有两种安装方式：<br><strong>源码编译安装</strong><br>这种方式灵活性最强，但这种方式不但会涉及TensorFlow GPU版本计算框架的依赖，还会牵扯到源码编译的工具依赖和库依赖。如果不是有特别的需要，不建议采用这种安装方式。<br><strong>二进制安装包安装</strong><br>针对大多数的使用场景，直接使用编译好的二进制安装包进行安装即可，操作相对简单，依赖也比较少。本文主要针对二进制安装包的方式进行安装。</p>
<h2 id="二进制安装包安装方式选择"><a href="#二进制安装包安装方式选择" class="headerlink" title="二进制安装包安装方式选择"></a>二进制安装包安装方式选择</h2><p><strong>参考TensorFlow官方文档</strong><br>TensorFlow官方文档提供了基于命令方式的安装模式。但实际上，文档提供的安装命令更多是一种参考，而不是针对所有显卡和硬件环境都可以适用的，傻瓜式解决方案。或者说，直接按照TensorFlow的官网提供命令进行安装，多半会出现问题。<br><strong>自定义安装</strong><br>TensorFlow CPU版本和GPU版本最大的不同在于它们依赖的硬件平台，CPU版本的硬件依赖比较低，甚至可以粗糙的认为对硬件没有特别的要求（桌面或工作站处理器，大多是基于X86计算架构的）。GPU则不同，即便大家目前使用的GPU卡大多是Nvidia的，但Nvidia不同的显卡系列的计算能力和对TensorFlow的支持也是不一样的。所以有必要针对自己实际的GPU显卡，配置与之相对应的运行环境，最终满足TensorFlow GPU版本的运行要求。</p>
<h2 id="TensorFlow-GPU版本的运行依赖"><a href="#TensorFlow-GPU版本的运行依赖" class="headerlink" title="TensorFlow GPU版本的运行依赖"></a>TensorFlow GPU版本的运行依赖</h2><p>GPU版本的TensorFlow运行依赖并不复杂，从底层到上层，依赖关系如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/4905018-e64598fdad6c2325.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="运行依赖"></p>
<p><strong>显卡</strong><br>目前深度学习使用的主流GPU大多是Nvidia的显卡。而大家常用的是GeForce系列和Tesla系列。从Nvidia的角度，GeForce系列定位在游戏市场，Tesla系列定位在数据中心。但实际上从经济考虑，很多公司都使用GeForce做模型训练，然后使用Tesla做线上服务（Nvidia禁止公司使用Tesla系列之外的显卡作为数据中心）。<br><strong>驱动</strong><br>驱动运行在系统的内核态，是操作系统的一部分，直接跟显卡硬件打交道，是应用层和硬件打交道的门户。不同的显卡需要不同的驱动。<br><strong>CUDA</strong><br>CUDA运行在系统的应用层，对通用GPU计算操作做了封装，方便其他组件调用。<br><strong>cuDNN</strong><br>cuDNN依赖CUDA库，封装了常用的深度学习方法，供更上层的组件调用。<br><strong>TensorFlow GPU版本要求</strong><br>不同版本的TensorFlow，对运行环境是有不同的要求。驱动版本的选择，主要依赖于显卡型号。而CUDA、cuDNN、Python版本的选择，则需要依赖TensorFlow GPU版本的选择：<br><img src="https://upload-images.jianshu.io/upload_images/4905018-726584ec5bee3647.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="依赖版本"><br>参考：<a href="https://www.tensorflow.org/install/source" target="_blank" rel="external">https://www.tensorflow.org/install/source</a></p>
<p>在有了显卡之后，后面需要做的，就是从下到上，安装对应版本的驱动、CUDA库、cuDNN库、Python和TensorFlow了。</p>
<h2 id="具体环境搭建步骤"><a href="#具体环境搭建步骤" class="headerlink" title="具体环境搭建步骤"></a>具体环境搭建步骤</h2><p>下面我们以超微的GPU工作站为例，逐步搭建TensorFlow GPU开发环境。<br><strong>系统环境</strong></p>
<ul>
<li>GTX 1080TI 四卡</li>
<li>Ubuntu 16.04</li>
<li>目标：TensorFlow GPU 1.10.0版本</li>
</ul>
<p><strong>（一）驱动安装</strong><br>驱动选择地址：<a href="https://www.nvidia.com/Download/index.aspx?lang=en-us" target="_blank" rel="external">https://www.nvidia.com/Download/index.aspx?lang=en-us</a><br><img src="https://upload-images.jianshu.io/upload_images/4905018-7d32ed5c819f8dc7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="驱动选择"><br>最终，会下载得到xxx.run的安装文件，直接使用shell安装，</p>
<pre><code># sudo sh xxx.run
</code></pre><p><strong>（二）CUDA安装</strong><br>下载地址：<a href="https://developer.nvidia.com/cuda-zone" target="_blank" rel="external">https://developer.nvidia.com/cuda-zone</a><br><img src="https://upload-images.jianshu.io/upload_images/4905018-4af061cba4cfd665.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="最新CUDA"><br>我们需要安装的TensorFlow GPU版本为1.10.0，所以CUDA的版本是9。但直接打开是最新版本的CUDA。可以选择上面的“Legacy Releases”，然后，选择需要的版本，<br><img src="https://upload-images.jianshu.io/upload_images/4905018-1dcf34269d5c370f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="对应版本CUDA"><br>最终，会下载得到xxx.run的安装文件，直接使用shell命令进行安装，</p>
<pre><code># sudo sh xxx.run
</code></pre><p><strong>（三）CUDNN安装</strong><br>下载地址（需要注册）：<a href="https://developer.nvidia.com/cudnn" target="_blank" rel="external">https://developer.nvidia.com/cudnn</a><br>cuDNN主要和CUDA版本对齐，<br><img src="https://upload-images.jianshu.io/upload_images/4905018-b0030c20943724b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="cuDNN"><br>cuDNN主要下载两个文件，<br><img src="https://upload-images.jianshu.io/upload_images/4905018-6933e5f4e092925b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="两个文件"><br>下载的两个xxx.deb文件，通过dpkg -i命令进行安装，</p>
<pre><code># dpkg -i xxx.deb
</code></pre><p><strong>（四）Python安装</strong><br>Python可以采用Anaconda环境，具体的安装步骤就不详细展开了，工作中选择了Python3.6版本。只提两点：<br><strong>全局环境变量设置</strong><br>Anaconda默认会将环境变量设置到~/.bashrc文件中。如果想全局可见，可以手动在/etc/profile文件中添加环境变量。<br><strong>使用清华的下载链接</strong><br>Anaconda的官方下载，国内下载速度很慢，可以直接使用清华的源。<br>地址：<a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/" target="_blank" rel="external">https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/</a><br><strong>（五）TensorFlow GPU安装</strong><br>TensorFlow安装先对简单，直接使用pip命令进行安装即可，但低于1.13.0版本的TensorFlow GPU版本，不能直接使用“pip install tensorflow-gup===xxx”来安装。需要手动下载安装文件，然后进行安装。<br>TensorFlow GPU历史版本下载地址：<a href="https://pypi.org/project/tensorflow-gpu/" target="_blank" rel="external">https://pypi.org/project/tensorflow-gpu/</a><br><img src="https://upload-images.jianshu.io/upload_images/4905018-8e91236a94f8f8a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="历史版本"><br>TensorFlow GPU也可以使用清华的源，但源更新的可能不够及时：<br>清华TensorFlow GPU地址：<a href="https://mirrors.tuna.tsinghua.edu.cn/help/tensorflow/" target="_blank" rel="external">https://mirrors.tuna.tsinghua.edu.cn/help/tensorflow/</a><br><img src="https://upload-images.jianshu.io/upload_images/4905018-8d5ccc9b25aba2f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="清华地址"></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>TensorFlow的GPU版本安装，本身并不复杂。关键是要梳理清楚不同组件的依赖关系。不同组件之间没有特别的强依赖，如果发现其中的某个组件有问题，单独卸载和重装即可。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/02/《从零开始学习自然语言处理-NLP-》-DeepPavlov框架解析（4）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liu Caiquan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="才权的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/03/02/《从零开始学习自然语言处理-NLP-》-DeepPavlov框架解析（4）/" itemprop="url">
                  《从零开始学习自然语言处理(NLP)》-DeepPavlov框架解析（4）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-02T19:49:19+08:00">
                2019-03-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>由于图片外链被禁止了，图片不能显示，完整文章看这里吧：<a href="https://zhuanlan.zhihu.com/p/58133705" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/58133705</a></p>
<h2 id="写在最前面"><a href="#写在最前面" class="headerlink" title="写在最前面"></a>写在最前面</h2><p>在这个日新月异的信息时代，海量数据的积累，计算能力的不断提升，机器学习尤其是深度学习的蓬勃发展，使得人工智能技术在不同领域焕发出蓬勃的活力。自己经历了嵌入式开发，移动互联网开发，目前从事自然语言处理算法开发工作。从工程软件开发到自然语言处理算法开发，希望通过这个系列的文章，能够由浅入深，通俗易懂的介绍自然语言处理的领域知识，分享自己的成长，同大家一起进步。</p>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在上一篇《从零开始学习自然语言处理(NLP)-NLP Framework开源方案梳理(3)》中梳理了目前流行的NLP开源框架，这里重点介绍下DeepPavlov框架。DeepPavlov框架的模型实用性很强，对实际的生产开发有很大的借鉴意义。</p>
<h2 id="框架组成"><a href="#框架组成" class="headerlink" title="框架组成"></a>框架组成</h2><p>DeepPavlov是一个基于TensorFlow和Keras的，专门针对对话系统研究和实验部署的自然语言处理框架。<br>项目地址：<a href="http://docs.deeppavlov.ai/en/master/#" target="_blank" rel="external">http://docs.deeppavlov.ai/en/master/#</a><br>框架主要包括：<br><strong>常用的NLP模型（包括Pre-train模型）</strong><br>如词向量训练、分类、命名实体识别（NER）、相似度计算等；<br><strong>针对对话系统实现和评测的实验框架（Framework）</strong><br>基于Json文件进行开发流程和数据流pipeline配置；<br><strong>提供同第三方应用进行集成的工具</strong><br>如与Amazon Alexa和Microsoft Bot Framework的集成；<br><strong>为对话模型的评测提供Benchmark环境</strong><br>DeepPavlov的默认Pre-train模型和测评数据集主要基于英文和俄文，对于中文场景需要做适当的调整。</p>
<h2 id="框架使用对象"><a href="#框架使用对象" class="headerlink" title="框架使用对象"></a>框架使用对象</h2><p><strong>新模型开发者</strong><br>方便同已有Benchmark模型进行对比评测<br><strong>普通NLP任务处理者</strong><br>如针对内容审核任务，敏感信息增加掩码等任务，可以直接使用框架提供的分类和序列标注模型，完成业务服务的快速开发和测评；<br><strong>对话系统开发者</strong><br>DeepPavlov是为对话系统场景量身定制的。对话系统开发者，可以直接参考使用；<br><strong>对话系统应用开发者</strong><br>DeepPavlov框架为应用集成提供了专门的工具，可以直接与Amazon Alexa，Microsoft Bot Framework等平台进行对接。</p>
<h2 id="框架使用"><a href="#框架使用" class="headerlink" title="框架使用"></a>框架使用</h2><p><strong>规范开发流程</strong><br>框架将数据模型服务的开发和验证流程（如数据清洗、模型设计、模型训练、模型选优、模型评测），使用Json配置文件串联成pipeline。能够很好的规范开发流程；<br><strong>新模型对比评测</strong><br>为对话模型的评测提供Benchmark环境，方便新模型的对比评测。但环境主要基于英文和俄文，对于中文任务，需要重新训练对比；<br><strong>常用NLP模型使用</strong><br>框架内置了很多常用模型（以分类为例，就包含了cnn_model，bilstm_model，bilstm_attention_model，transformer_model等12种模型实现），在项目中可以直接使用；<br>同时框架提供了Pre-train模型，但主要是基于英文和俄文的，对于中文场景需要自己进行重新训练；<br><strong>对话系统开发</strong><br>DeepPavlov是为对话系统场景量身定制的，对话系统开发者，可以直接参考使用；</p>
<h2 id="DeepPavlov框架层次"><a href="#DeepPavlov框架层次" class="headerlink" title="DeepPavlov框架层次"></a>DeepPavlov框架层次</h2><p>DeepPavlov从整体到局部，可分为如下三个层次：<br><img src="https://upload-images.jianshu.io/upload_images/4905018-f4c0014e182c870b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="DeepPavlov框架层次"><br>下面我们从外层到内层，逐层介绍DeepPavlov的框架设计。</p>
<h2 id="DeepPavlov顶层框架"><a href="#DeepPavlov顶层框架" class="headerlink" title="DeepPavlov顶层框架"></a>DeepPavlov顶层框架</h2><p><img src="https://upload-images.jianshu.io/upload_images/4905018-c0f6ca8cbb1f27c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="DeepPavlov框架"><br><strong>Agent</strong><br>同用户直接交互的代理，直接接收用户输入的纯文本信息（raw text）<br><strong>Skill</strong><br>领域技能，如基于意图-词槽的任务型技能，基于Seq2Seq的闲聊技能，基于知识图谱的知识问答技能；<br><strong>Skill Manager</strong><br>确定用户query，选择使用哪些skill，并确定将哪一个skill的召回结果作为最终的回复；<br><strong>Component</strong><br>Skill实现的组成部分，如针对任务型技能，包括数据预处理component、意图识别component、slotfilling component等；<br><strong>Chainer</strong><br>Chainer以Json配置文件的形式，将某个skill相关的所有component串联起来；<br><strong>Data Storage</strong><br>框架本身包含的Pre-train模型和Benchmark评测数据集</p>
<h2 id="Skill框架"><a href="#Skill框架" class="headerlink" title="Skill框架"></a>Skill框架</h2><p>DeepPavlov内置的skill主要包括：<br><strong>任务型skill（Goal-Oriented Dialogue Bot）</strong><br>基于意图/词槽/对话管理等component实现的问答skill。<br><img src="https://upload-images.jianshu.io/upload_images/4905018-aa3877cb08461905.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="任务型skill"><br><strong>阅读理解skill（Open-Domain Question Answering）</strong><br>基于阅读理解实现问答skill。相对于阅读理解component（Context Question Answering），skill还包含在多个召回结果中进行排序的能力。<br><strong>规则型skill（Pattern Matching）</strong><br>基于自定义规则实现问答skill。<br><strong>Seq2Seq skill（Sequence-To-Sequence Dialogue Bot）</strong><br>基于Seq2Seq实现问答skill。<br><img src="https://upload-images.jianshu.io/upload_images/4905018-20ec116fa7907873.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Seq2Seq skill"><br><strong>常见问题问答skill（Frequently Asked Questions Answering）</strong><br>先将句子嵌入为向量（使用词向量叠加），然后做分类处理（给每一个answer一个打分），选取打分最高的answer作为最终回复的skill。<br><strong>商品查询skill（eCommerce Bot）</strong><br>商品查询回复skill，支持多轮（添加过滤条件）。下面是场景示例，<br><img src="https://upload-images.jianshu.io/upload_images/4905018-99c0ebb7de6cc02f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="商品查询skill"></p>
<h2 id="基本能力框架"><a href="#基本能力框架" class="headerlink" title="基本能力框架"></a>基本能力框架</h2><p>DeepPavlov内置的基本能力主要包括：<br><strong>数据预处理component（Data processors）</strong><br>主要提供包括分词、嵌入向量化等预处理能力（主要基于俄文和英文）。<br><strong>阅读理解component（Context Question Answering）</strong><br>相对于阅读理解skill（Open-Domain Question Answering），component不包含对多个召回结果进行排序（rank）的能力。具体的处理场景示例如下，<br><img src="https://upload-images.jianshu.io/upload_images/4905018-b5316fe0884017ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="阅读理解component"><br><strong>分类component（Classification）</strong><br>分类组件，可以用来做场景和意图的分类。<br><strong>Morphological Tagger component</strong><br>一种特殊的POS？<br><strong>命名实体识别component（Named Entity Recognition）</strong><br>NER能力组件。<br><strong>相似度计算component（Neural Ranking）</strong><br>通过基于孪生网络完成相似度计算，实现在标准问答库中标准答复的查找。<br><strong>词槽填充component（Slot filling）</strong><br>在NER的基础上，增加了词表限制。<br><strong>*拼写纠错component（Spelling Correction）</strong><br>提供了两种纠错方法：</p>
<ul>
<li>levenshtein_corrector ：基于编辑距离</li>
<li>brillmoore：基于统计模型</li>
</ul>
<p><strong>TF-IDF排序component（TF-IDF Ranking）</strong><br>基于TF-IDF的文档召回排序。<br><strong>流行度排序component（Popularity Ranking）</strong><br>将TF-IDF打分和流行度打分作为特征，通过逻辑回归计算流行度，最终实现排序。</p>
<h2 id="Json配置文件解析"><a href="#Json配置文件解析" class="headerlink" title="Json配置文件解析"></a>Json配置文件解析</h2><p>DeepPavlov通过Json配置文件实现开发流程控制和数据流pipeline的控制。<br>上面提到DeepPavlov主要分为Agent、Skill和Component三个层次。而Json配置文件主要应用在Skill和Component这两个层面。而对Agent的控制，框架通过直接的代码来实现，例如，<br><img src="https://upload-images.jianshu.io/upload_images/4905018-35bbd3ed436a7545.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="agent"><br>其中，<br><strong>skills</strong><br>Agent支持的所有skill列表；<br><strong>skills_filter</strong><br>针对用户query，确定Agent使用哪些skill；<br><strong>skills_filter</strong><br>通过召回的不同skill结果，确定最后的回复内容给用户；<br>下面我们具体的介绍下Json配置文件的具体结构。</p>
<h2 id="Json配置文件结构"><a href="#Json配置文件结构" class="headerlink" title="Json配置文件结构"></a>Json配置文件结构</h2><p><img src="https://upload-images.jianshu.io/upload_images/4905018-6f83f4dcefee7713.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Json配置文件结构"><br>如上图所示，Json配置文件主要由如下五个部分组成（参考分类component）：<br><strong>dataset_reader</strong><br>主要负责数据的读取。<br><img src="https://upload-images.jianshu.io/upload_images/4905018-ba0d381b6d858e97.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="dataset_reader"><br><strong>dataset_iterator</strong><br>数据迭代器，从dataset_reader中获得数据，然后按batch抽取数据，供后面的模型训练使用。<br><img src="https://upload-images.jianshu.io/upload_images/4905018-0e61711decf24e69.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="dataset_iterator"><br><strong>chainer</strong><br>配置文件的核心，将数据预处理、模型选优和模型预测输出，通过pipeline（”pipe”字段内进行约束）的形式串联起来。</p>
<pre><code>&quot;chainer&quot;: {
&quot;in&quot;: [
  &quot;x&quot;
],
&quot;in_y&quot;: [
  &quot;y&quot;
],
&quot;pipe&quot;: [
  {
    &quot;id&quot;: &quot;classes_vocab&quot;,
    &quot;class_name&quot;: &quot;simple_vocab&quot;,
    &quot;fit_on&quot;: [
      &quot;y&quot;
    ],
    &quot;save_path&quot;: &quot;{MODELS_PATH}/classifiers/{PROJECT_NAME}_{MODEL_NAME}/classes.dict&quot;,
    &quot;load_path&quot;: &quot;{MODELS_PATH}/classifiers/{PROJECT_NAME}_{MODEL_NAME}/classes.dict&quot;,
    &quot;in&quot;: &quot;y&quot;,
    &quot;out&quot;: &quot;y_ids&quot;
  },
  {
    &quot;in&quot;: &quot;x&quot;,
    &quot;out&quot;: &quot;x_tok&quot;,
    &quot;id&quot;: &quot;my_tokenizer&quot;,
    &quot;class_name&quot;: &quot;char_tokenizer&quot;,
    &quot;tokenizer&quot;: &quot;char_tokenizer&quot;
  },
  {
    &quot;in&quot;: &quot;x_tok&quot;,
    &quot;out&quot;: &quot;x_ids&quot;,
    &quot;id&quot;: &quot;seq_to_emb_ids&quot;,
    &quot;class_name&quot;: &quot;seq_to_emb_ids&quot;,
    &quot;emb_file_path&quot;:&quot;{EMBED_PATH}&quot;,
    &quot;text_size&quot;:250
  },
  {
    &quot;in&quot;: &quot;y_ids&quot;,
    &quot;out&quot;: &quot;y_onehot&quot;,
    &quot;class_name&quot;: &quot;one_hotter&quot;,
    &quot;id&quot;: &quot;my_one_hotter&quot;,
    &quot;single_vector&quot;: true,
    &quot;depth&quot;: &quot;#classes_vocab.len&quot;
  },
  {
    &quot;in&quot;: [
      &quot;x_ids&quot;
    ],
    &quot;fit_on_batch_preprocess&quot;: [
      &quot;x_ids&quot;,
      &quot;y_onehot&quot;
    ],
    &quot;out&quot;: [
      &quot;y_pred_probas&quot;
    ],
    &quot;main&quot;: true,
    &quot;class_name&quot;: &quot;keras_classifier_model&quot;,
    &quot;graph_metrics&quot;: &quot;multilabel_f1&quot;,
    &quot;save_path&quot;: &quot;{MODELS_PATH}/classifiers/{PROJECT_NAME}_{MODEL_NAME}/model&quot;,
    &quot;load_path&quot;: &quot;{MODELS_PATH}/classifiers/{PROJECT_NAME}_{MODEL_NAME}/model&quot;,
    &quot;n_classes&quot;: &quot;#classes_vocab.len&quot;,
    &quot;train_emb&quot;: false,
    &quot;kernel_sizes_cnn&quot;: [
      1,
      2,
      3,
      4,
      5
    ],
    &quot;filters_cnn&quot;: 512,
    &quot;optimizer&quot;: &quot;Adam&quot;,
    &quot;learning_rate&quot;: 0.001,
    &quot;learning_rate_decay&quot;: 0.9,
    &quot;loss&quot;: &quot;categorical_crossentropy&quot;,
    &quot;embedding_matrix&quot;: &quot;#seq_to_emb_ids.matrix&quot;,
    &quot;text_size&quot;: 250,
    &quot;last_layer_activation&quot;: &quot;softmax&quot;,
    &quot;coef_reg_cnn&quot;: 0.0,
    &quot;coef_reg_den&quot;: 0.0,
    &quot;dropout_rate&quot;: 0.5,
    &quot;dense_size&quot;: 30,
    &quot;model_name&quot;: &quot;cnn_model&quot;
  },
  {
    &quot;in&quot;: &quot;y_pred_probas&quot;,
    &quot;out&quot;: &quot;y_pred_ids&quot;,
    &quot;class_name&quot;: &quot;proba2labels&quot;,
    &quot;max_proba&quot;: true
  },
  {
    &quot;in&quot;: &quot;y_pred_ids&quot;,
    &quot;out&quot;: &quot;y_pred_onehot&quot;,
    &quot;ref&quot;: &quot;my_one_hotter&quot;
  },
  {
    &quot;in&quot;: &quot;y_pred_ids&quot;,
    &quot;out&quot;: &quot;y_pred_labels&quot;,
    &quot;ref&quot;: &quot;classes_vocab&quot;
  }
],
&quot;out&quot;: [
  &quot;y_pred_ids&quot;,
  &quot;y_pred_onehot&quot;,
  &quot;y_pred_labels&quot;,
  &quot;y_pred_probas&quot;
]
},
</code></pre><p>官方文档中，将“pipe”字段内的每一对花括号({})中的内容成为一个component（注意这里的component和上面提到的框架component是不同的。为了方便区分，我们将”pipe”中的component标识为pipe-component）。<br><strong>train</strong><br>模型训练、模型选优和评测配置。</p>
<pre><code>&quot;train&quot;: {
&quot;epochs&quot;: 10,
&quot;batch_size&quot;: 256,
&quot;metrics&quot;: [
  {
    &quot;name&quot;: &quot;cal_confusion_matrix&quot;,
    &quot;inputs&quot;: [
      &quot;y&quot;,
      &quot;y_pred_labels&quot;
    ]
  },
  {
    &quot;name&quot;: &quot;f1_micro&quot;,
    &quot;inputs&quot;: [
      &quot;y&quot;,
      &quot;y_pred_labels&quot;
    ]
  },
  {
    &quot;name&quot;: &quot;recall_micro&quot;,
    &quot;inputs&quot;: [
      &quot;y_ids&quot;,
      &quot;y_pred_ids&quot;
    ]
  },
  {
    &quot;name&quot;: &quot;precision_micro&quot;,
    &quot;inputs&quot;: [
      &quot;y_onehot&quot;,
      &quot;y_pred_onehot&quot;
    ]
  },
  {
    &quot;name&quot;: &quot;f1_macro&quot;,
    &quot;inputs&quot;: [
      &quot;y_onehot&quot;,
      &quot;y_pred_onehot&quot;
    ]
  },
  {
    &quot;name&quot;: &quot;precision_macro&quot;,
    &quot;inputs&quot;: [
      &quot;y&quot;,
      &quot;y_pred_labels&quot;
    ]
  },
  {
    &quot;name&quot;: &quot;recall_macro&quot;,
    &quot;inputs&quot;: [
      &quot;y_ids&quot;,
      &quot;y_pred_ids&quot;
    ]
  },
  {
    &quot;name&quot;: &quot;recall_group&quot;,
    &quot;inputs&quot;: [
      &quot;y_onehot&quot;,
      &quot;y_pred_onehot&quot;
    ]
  },
  {
    &quot;name&quot;: &quot;precision_group&quot;,
    &quot;inputs&quot;: [
      &quot;y&quot;,
      &quot;y_pred_labels&quot;
    ]
  },
  {
    &quot;name&quot;: &quot;f1_group&quot;,
    &quot;inputs&quot;: [
      &quot;y_ids&quot;,
      &quot;y_pred_ids&quot;
    ]
  }
],
&quot;validation_patience&quot;: 5,
&quot;val_every_n_epochs&quot;: 1,
&quot;log_every_n_epochs&quot;: 1,
&quot;show_examples&quot;: true,
&quot;validate_best&quot;: true,
&quot;test_best&quot;: true,
&quot;report_path&quot;: &quot;{MODELS_PATH}/classifiers/{PROJECT_NAME}_{MODEL_NAME}/report.xlsx&quot;
},
</code></pre><p>其中，<br>“metric”字段中排在最前面的指标，作为模型选优的标准。<br><strong>metadata</strong><br>相关相关的常量配置。<br><img src="https://upload-images.jianshu.io/upload_images/4905018-4b3fafd2b9128a17.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="metadata"><br>其中，”imports”是DeepPavlov框架之外自定义实现。</p>
<h2 id="DeepPavlov存在的问题"><a href="#DeepPavlov存在的问题" class="headerlink" title="DeepPavlov存在的问题"></a>DeepPavlov存在的问题</h2><p><strong>环境依赖</strong><br>DeepPavlov是基于TensorFlow和Keras实现的，不能继承其他计算框架的模型实现（如PyTorch）。<br><strong>语言支持</strong><br>Pre-train模型和评测数据集主要基于英文和俄文，不支持中文。<br><strong>生产环境部署</strong><br>DeepPavlov在运行时需要依赖整个框架源码，开发环境对框架修改后，生产环境需要更新整个框架。同时，也不能直接将功能Component作为服务独立导出，不适合在生产环境的部署和发布。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/24/《TensorFlow内核剖析》笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liu Caiquan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="才权的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/02/24/《TensorFlow内核剖析》笔记/" itemprop="url">
                  《TensorFlow内核剖析》笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-24T19:40:33+08:00">
                2019-02-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>由于图片外链被禁止了，图片不能显示，完整文章看这里吧：<a href="https://zhuanlan.zhihu.com/p/57559407" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/57559407</a></p>
<p>市面上对TensorFlow使用介绍的书非常之多，但剖析原理的却很少。如果对TensorFlow的底层实现感兴趣，刘光聪的《TensorFlow内核剖析》是一个不错的选择。同时，这是一本开源技术书，可以免费获得。</p>
<h2 id="DistBelife框架"><a href="#DistBelife框架" class="headerlink" title="DistBelife框架"></a>DistBelife框架</h2><p><img src="https://upload-images.jianshu.io/upload_images/4905018-4353758491c42988.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="DistBelife框架"></p>
<h2 id="DistBelief缺点"><a href="#DistBelief缺点" class="headerlink" title="DistBelief缺点"></a>DistBelief缺点</h2><p><img src="https://upload-images.jianshu.io/upload_images/4905018-8e7217b17816c5f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="DistBelief缺点"></p>
<h2 id="TensorFlow设计原则"><a href="#TensorFlow设计原则" class="headerlink" title="TensorFlow设计原则"></a>TensorFlow设计原则</h2><p><img src="https://upload-images.jianshu.io/upload_images/4905018-61167f0c483ebef2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TensorFlow设计原则"></p>
<h2 id="TensorFlow优势"><a href="#TensorFlow优势" class="headerlink" title="TensorFlow优势"></a>TensorFlow优势</h2><p><img src="https://upload-images.jianshu.io/upload_images/4905018-b5274b1e0a620542.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TensorFlow优势"></p>
<h2 id="TensorFlow里程碑"><a href="#TensorFlow里程碑" class="headerlink" title="TensorFlow里程碑"></a>TensorFlow里程碑</h2><p><img src="https://upload-images.jianshu.io/upload_images/4905018-5a1f4453b8c12fbf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TensorFlow里程碑"></p>
<h2 id="TensorFlow技术栈"><a href="#TensorFlow技术栈" class="headerlink" title="TensorFlow技术栈"></a>TensorFlow技术栈</h2><p><img src="https://upload-images.jianshu.io/upload_images/4905018-fc46239d6f9e5447.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TensorFlow技术栈"></p>
<h2 id="TensorFlow系统架构"><a href="#TensorFlow系统架构" class="headerlink" title="TensorFlow系统架构"></a>TensorFlow系统架构</h2><p><strong>TensorFlow系统架构</strong><br><img src="https://upload-images.jianshu.io/upload_images/4905018-64be0bebce3b0fea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TensorFlow系统架构"><br><strong>说明</strong><br><img src="https://upload-images.jianshu.io/upload_images/4905018-b9adaaea3bf849d0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="说明"><br><strong>Client</strong><br><img src="https://upload-images.jianshu.io/upload_images/4905018-9edbf4350c1eb435.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Client"><br><strong>Master</strong><br><img src="https://upload-images.jianshu.io/upload_images/4905018-3a4a8f95f10fbdd8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Master"><br><strong>Worker</strong><br><img src="https://upload-images.jianshu.io/upload_images/4905018-a9d3670a01be4c17.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Worker"><br><strong>Kernel</strong><br><img src="https://upload-images.jianshu.io/upload_images/4905018-0d571744e78612d5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Kernel"></p>
<h2 id="集群组建"><a href="#集群组建" class="headerlink" title="集群组建"></a>集群组建</h2><p><img src="https://upload-images.jianshu.io/upload_images/4905018-fc9adc70dba88bf6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="集群组建"></p>
<h2 id="本地模式"><a href="#本地模式" class="headerlink" title="本地模式"></a>本地模式</h2><p><strong>本地模式</strong><br><img src="https://upload-images.jianshu.io/upload_images/4905018-7fbc67ed7ad2c16e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="本地模式"><br><strong>本地模式：图操作</strong><br><img src="https://upload-images.jianshu.io/upload_images/4905018-19beefd44fa712ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="本地模式：图操作"></p>
<h2 id="分布式模式"><a href="#分布式模式" class="headerlink" title="分布式模式"></a>分布式模式</h2><p><strong>分布式模式</strong><br><img src="https://upload-images.jianshu.io/upload_images/4905018-8421bbe8a067bf2f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="分布式模式"><br><strong>分布式模式-图操作</strong><br><img src="https://upload-images.jianshu.io/upload_images/4905018-078e3463fda1933b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="分布式模式-图操作"><br><strong>PS与Worker</strong><br><img src="https://upload-images.jianshu.io/upload_images/4905018-30a2d980b9f325ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="PS与Worker"><br><strong>服务互联</strong><br><img src="https://upload-images.jianshu.io/upload_images/4905018-889d5c03ed5237d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="服务互联"><br><strong>单Client接入集群</strong><br><img src="https://upload-images.jianshu.io/upload_images/4905018-1cb2f9c97633ede4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="单Client接入集群"><br><strong>多Client接入集群</strong><br><img src="https://upload-images.jianshu.io/upload_images/4905018-2361f428ce897631.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="多Client接入集群"><br><strong>会话协同</strong><br><img src="https://upload-images.jianshu.io/upload_images/4905018-533b782f7bbf85fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="会话协同"><br><strong>会话控制领域模型</strong><br><img src="https://upload-images.jianshu.io/upload_images/4905018-7a2cfa2712dc4900.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="会话控制领域模型"><br><strong>获取远端设备集</strong><br><img src="https://upload-images.jianshu.io/upload_images/4905018-550f9faaa2881cdb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="获取远端设备集"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/01/《从零开始学习自然语言处理-NLP-》-NLP-Framework开源方案梳理-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liu Caiquan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="才权的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/02/01/《从零开始学习自然语言处理-NLP-》-NLP-Framework开源方案梳理-3/" itemprop="url">
                  《从零开始学习自然语言处理(NLP)》-NLP Framework开源方案梳理(3)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-01T21:20:16+08:00">
                2019-02-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>由于图片外链被禁止了，图片不能显示，完整文章看这里吧：<a href="https://zhuanlan.zhihu.com/p/56159591" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/56159591</a></p>
<h2 id="写在最前面"><a href="#写在最前面" class="headerlink" title="写在最前面"></a>写在最前面</h2><p>在这个日新月异的信息时代，海量数据的积累，计算能力的不断提升，机器学习尤其是深度学习的蓬勃发展，使得人工智能技术在不同领域焕发出蓬勃的活力。自己经历了嵌入式开发，移动互联网开发，目前从事自然语言处理算法开发工作。从工程软件开发到自然语言处理算法开发，希望通过这个系列的文章，能够由浅入深，通俗易懂的介绍自然语言处理的领域知识，分享自己的成长，同大家一起进步。</p>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>新的项目开启时，一般会经历如下的流程：</p>
<ul>
<li>业务需求梳理</li>
<li>算法方案选择</li>
<li>模型实现：选择开源方案，或自己实现</li>
<li>模型训练：数据清洗、模型训练（使用训练集）</li>
<li>最优模型选择：依据验证集结果，选择最优模型</li>
<li>模型评测：依据测试集结果，对模型进行评测</li>
<li>模型优化：本模型调优，或选择新的模型</li>
<li>模型服务上线</li>
</ul>
<p>而在实际的项目开发中，存在如下的问题：<br><strong>1模型实现问题</strong><br>模型实现一般会选择开源方案，或自己编码实现。自己编码实现开发和调试成本高。直接选择开源方案，会面临开发环境不统一，编译问题，代码结果和可靠性难以保证等问题；<br><strong>2模型训练和评测问题</strong><br>该阶段会设计到数据清洗，输入读入，数据迭代器设计，数据预处理，词向量训练与准备，分词，文本转索引，<br>标签ont-hot表示，训练集/验证集/测试集划分，训练过程最优模型选择，模型评测(准确度A、精确度P、召回率R、F1值等)，数据分析（结果分析，混淆矩阵分析，ROC/AUC分析），Tensorboard结果查看等。由于该部分设计的流程和步骤较多，自己编码开发和调试工作量大，而开源方案很多步骤和组件并不全面。<br><strong>3 模型优化问题</strong><br>除了在现有模型的基础上进行局部优化外，还会选择新的模型。如果选择新的模型，则会重新自己编码实现或选择开源方案，会再次经历前面提到的问题1（模型实现问题）和问题2（模型训练和评测问题）。<br><strong>4 模型服务上线问题</strong><br>模型服务上线，同模型的训练和预测和类似，但又不完全相同。模型上线需要和模型训练一样的预处理，词向量，分词，文本转索引等步骤，但不需要模型的测评。同时，模型上线要求只能包含模型的训练文件，<br>而不能包括模型的代码。通常需要编写专门的代码用于模型服务上线。<br>一般来说，针对上面的问题，公司都会有一个统一的NLP算法框架，<br><strong>一方面，统一模型的实现、评测和上线流程</strong><br><strong>另一方面，框架自身包含很多现成的模型，便于业务在算法落地方面的快速验证</strong><br>大多数公司并不开源自己的NLP算法框架，但开源社区NLP开源框架还是蛮多的，这里做一个统一的梳理。</p>
<h2 id="针对对话系统的Framework"><a href="#针对对话系统的Framework" class="headerlink" title="针对对话系统的Framework"></a>针对对话系统的Framework</h2><h3 id="1-DeepPavlov"><a href="#1-DeepPavlov" class="headerlink" title="1 DeepPavlov"></a>1 DeepPavlov</h3><p>运行依赖：TensorFlow/Keras<br>支持功能：<br><img src="https://upload-images.jianshu.io/upload_images/4905018-ffa015c3e2212104.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="支持功能"><br>项目地址：<br><a href="https://github.com/deepmipt/DeepPavlov" target="_blank" rel="external">https://github.com/deepmipt/DeepPavlov</a></p>
<h3 id="2-ParlAI"><a href="#2-ParlAI" class="headerlink" title="2 ParlAI"></a>2 ParlAI</h3><p>运行依赖：Pytorch<br>支持功能：<br><img src="https://upload-images.jianshu.io/upload_images/4905018-31a1018b9a6dc7bf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="支持功能"><br>项目地址：<a href="https://github.com/facebookresearch/ParlAI" target="_blank" rel="external">https://github.com/facebookresearch/ParlAI</a></p>
<h3 id="3-Rasa"><a href="#3-Rasa" class="headerlink" title="3 Rasa"></a>3 Rasa</h3><p>运行依赖：Python<br>支持功能：纯任务型对话<br>项目地址：<a href="https://www.rasa.com/" target="_blank" rel="external">https://www.rasa.com/</a></p>
<h3 id="4-OpenDial"><a href="#4-OpenDial" class="headerlink" title="4 OpenDial"></a>4 OpenDial</h3><p>运行依赖：Java<br>支持功能：对话系统<br>描述：主要基于传统方法，深度网络较少涉及。<br>项目地址：<a href="https://github.com/plison/opendial" target="_blank" rel="external">https://github.com/plison/opendial</a></p>
<h2 id="通用NLP-Framework"><a href="#通用NLP-Framework" class="headerlink" title="通用NLP Framework"></a>通用NLP Framework</h2><h3 id="1-Intel-NLP-Architect"><a href="#1-Intel-NLP-Architect" class="headerlink" title="1 Intel NLP-Architect"></a>1 Intel NLP-Architect</h3><p>运行依赖：TensorFlow<br>支持功能：<br><img src="https://upload-images.jianshu.io/upload_images/4905018-3869c6d90607bcf2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="支持功能"><br>项目地址：<a href="http://nlp_architect.nervanasys.com/" target="_blank" rel="external">http://nlp_architect.nervanasys.com/</a></p>
<h3 id="2-AllenNLP"><a href="#2-AllenNLP" class="headerlink" title="2 AllenNLP"></a>2 AllenNLP</h3><p>运行依赖：Pytorch<br>支持功能：<br><img src="https://upload-images.jianshu.io/upload_images/4905018-19871ec0e38c2f3a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="支持功能"><br>项目地址：<br><a href="https://allennlp.org/" target="_blank" rel="external">https://allennlp.org/</a></p>
<h3 id="3-PyText"><a href="#3-PyText" class="headerlink" title="3 PyText"></a>3 PyText</h3><p>运行依赖：Pytorch<br>支持功能：<br><img src="https://upload-images.jianshu.io/upload_images/4905018-658f4db3cb09b08d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="支持功能"><br>项目地址：<br><a href="https://pytext-pytext.readthedocs-hosted.com/en/latest/" target="_blank" rel="external">https://pytext-pytext.readthedocs-hosted.com/en/latest/#</a></p>
<h2 id="NLP基础依赖组件项目（提供pre-train模型）"><a href="#NLP基础依赖组件项目（提供pre-train模型）" class="headerlink" title="NLP基础依赖组件项目（提供pre-train模型）"></a>NLP基础依赖组件项目（提供pre-train模型）</h2><h3 id="1-Stanford-CoreNLP"><a href="#1-Stanford-CoreNLP" class="headerlink" title="1 Stanford CoreNLP"></a>1 Stanford CoreNLP</h3><p>运行依赖：Java<br>支持功能：<br><img src="https://upload-images.jianshu.io/upload_images/4905018-e62c769d3804da3e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="支持功能"><br>项目地址：<br><a href="https://stanfordnlp.github.io/CoreNLP/index.html" target="_blank" rel="external">https://stanfordnlp.github.io/CoreNLP/index.html</a></p>
<h3 id="2-Stanford-NLP"><a href="#2-Stanford-NLP" class="headerlink" title="2 Stanford NLP"></a>2 Stanford NLP</h3><p>运行依赖：Pytorch<br>支持功能：<br><img src="https://upload-images.jianshu.io/upload_images/4905018-84ece0293bf62370.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="支持功能"><br>项目地址：<br><a href="https://stanfordnlp.github.io/stanfordnlp/tokenize.html" target="_blank" rel="external">https://stanfordnlp.github.io/stanfordnlp/tokenize.html</a></p>
<h3 id="3-spaCy"><a href="#3-spaCy" class="headerlink" title="3 spaCy"></a>3 spaCy</h3><p>运行依赖：Python<br>支持功能：<br><img src="https://upload-images.jianshu.io/upload_images/4905018-b05fe1a8edb066c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="支持功能"><br>项目地址：<br><a href="https://spacy.io/" target="_blank" rel="external">https://spacy.io/</a></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文梳理了实际的业务算法落地开发过程，并提出了其中存在的问题，和解决方案。对当前开源的NLP框架做了整理，可以依据自身的需要开发自己的NLP算法框架，规范开发流程，提升业务落地效率。同时，也可以直接从开源方案中获取自己需求的算法实现模块。后续有新的开源框架方案，会持续整理进来。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/01/深度学习的高阶数学/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liu Caiquan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="才权的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/02/01/深度学习的高阶数学/" itemprop="url">
                  深度学习的高阶数学
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-01T21:18:03+08:00">
                2019-02-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>由于图片外链被禁止了，图片不能显示，完整文章看这里吧：<a href="https://zhuanlan.zhihu.com/p/56159815" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/56159815</a></p>
<p>有了基础的《概率/统计》、《线性代数》、《微积分》知识，就可以上手深度学习的算法和实践了。但经过一段时间的工程实践，慢慢觉得大多数时间都用在选模型，调超参，或者是网络结构的排列组合上。深度学习的黑盒特性越来越明显。难道深度学习工程师就当真是数据“炼丹师”吗？<br>如果，你有了这样的感觉，下面的视频不妨抽时间看看(都需要翻墙)：</p>
<h2 id="李宏毅《Machine-Learning-and-having-it-deep-and-structured》"><a href="#李宏毅《Machine-Learning-and-having-it-deep-and-structured》" class="headerlink" title="李宏毅《Machine Learning and having it deep and structured》"></a>李宏毅《Machine Learning and having it deep and structured》</h2><p>不多说，直接看目录吧。<br>课程地址：<a href="http://speech.ee.ntu.edu.tw/~tlkagk/courses_MLDS18.html" target="_blank" rel="external">http://speech.ee.ntu.edu.tw/~tlkagk/courses_MLDS18.html</a><br><strong>《Theory 1 - Why Deep Structure》</strong><br>&emsp;<a href="https://www.youtube.com/watch?v=KKT2VkTdFyc&amp;feature=youtu.be" target="_blank" rel="external">Can shallow network fit any function</a><br>&emsp;<a href="https://www.youtube.com/watch?v=FN8jclCrqY0&amp;feature=youtu.be" target="_blank" rel="external">Potential of Deep</a><br>&emsp;<a href="https://www.youtube.com/watch?v=qpuLxXrHQB4&amp;feature=youtu.be" target="_blank" rel="external">Is Deep better than Shallow</a><br><strong>《Theory 2 - Optimization》</strong><br>&emsp;<a href="https://www.youtube.com/watch?v=XSdkBG6Vvr0&amp;feature=youtu.be" target="_blank" rel="external">When Gradient is Zero</a><br>&emsp;<a href="https://www.youtube.com/watch?v=0O6nYRC7GeY&amp;feature=youtu.be" target="_blank" rel="external">Deep Linear Network</a><br>&emsp;<a href="https://www.youtube.com/watch?v=NmelPQkUark&amp;feature=youtu.be" target="_blank" rel="external">Does Deep Network have Local Minima</a><br>&emsp;<a href="https://www.youtube.com/watch?v=_VuWvQUMQVk&amp;feature=youtu.be" target="_blank" rel="external">Geometry of Loss Surfaces (Conjecture)</a><br>&emsp;<a href="https://www.youtube.com/watch?v=XysGHdNOTbg&amp;feature=youtu.be" target="_blank" rel="external">Geometry of Loss Surfaces (Empirical)</a><br><strong>《Theory 3 - Generalization 》</strong><br>&emsp;<a href="https://www.youtube.com/watch?v=9dtxv4HLq_8&amp;feature=youtu.be" target="_blank" rel="external">Capability of Generalization</a><br>&emsp;<a href="https://www.youtube.com/watch?v=pivB5jEBOQw&amp;feature=youtu.be" target="_blank" rel="external">Indicator of Generalization</a></p>
<h2 id="Sanjeev-Arora《The-mathematics-of-machine-learning-and-deep-learning》"><a href="#Sanjeev-Arora《The-mathematics-of-machine-learning-and-deep-learning》" class="headerlink" title="Sanjeev Arora《The mathematics of machine learning and deep learning》"></a>Sanjeev Arora《The mathematics of machine learning and deep learning》</h2><p>视频地址：<a href="https://www.youtube.com/watch?v=r07Sofj_puQ" target="_blank" rel="external">https://www.youtube.com/watch?v=r07Sofj_puQ</a><br>这是ICM2018的主题演讲，虽然Sanjeev Arora作为普林斯顿计算机科学的教授，但演讲内容深入浅出，并没有涉及大量的数学公式和推导，这里贴一下提纲：<br><img src="https://upload-images.jianshu.io/upload_images/4905018-7d5ed8e29ad63030.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="内容提纲"></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这两部分的内容是相互呼应的，可以先看李宏毅老师的课程，然后在看Sanjeev Arora教授的分享总结。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/27/《从零开始学习自然语言处理-NLP-》-TF-IDF算法-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liu Caiquan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="才权的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/01/27/《从零开始学习自然语言处理-NLP-》-TF-IDF算法-2/" itemprop="url">
                  《从零开始学习自然语言处理(NLP)》-TF-IDF算法(2)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-27T21:16:59+08:00">
                2019-01-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>由于图片外链被禁止了，图片不能显示，完整文章看这里吧：<a href="https://zhuanlan.zhihu.com/p/55843621" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/55843621</a></p>
<h1 id="写在最前面"><a href="#写在最前面" class="headerlink" title="写在最前面"></a>写在最前面</h1><p>在这个日新月异的信息时代，海量数据的积累，计算能力的不断提升，机器学习尤其是深度学习的蓬勃发展，使得人工智能技术在不同领域焕发出蓬勃的活力。自己经历了嵌入式开发，移动互联网开发，目前从事自然语言处理算法开发工作。从工程软件开发到自然语言处理算法开发，希望通过这个系列的文章，能够由浅入深，通俗易懂的介绍自然语言处理的领域知识，分享自己的成长，同大家一起进步。</p>
<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>在上一篇文章中（<a href="https://zhuanlan.zhihu.com/p/55296265" target="_blank" rel="external">《《从零开始学习自然语言处理(NLP)》-倒排索引(1)》</a>）描述了基于关键词搜索的基本原理，以及通过倒排索引来提升和关键词相关网页的查询。本文在上文的基础上提出一个新的问题：<br>如果通过倒排索引查找到的网页都包含<strong>全部的</strong>查询关键字，而且，召回（符合查找条件）的网页数目又很多，这就需要将网页与查询Query的相关度进行排序了。相关度高的网页排在查询结果的前面，相关度低的网页排在后面。那问题来了，如何依据网页与查询关键词的相关性对召回的网页做排序呢？</p>
<h1 id="基于TF（Term-Frequency，词频）进行排序"><a href="#基于TF（Term-Frequency，词频）进行排序" class="headerlink" title="基于TF（Term Frequency，词频）进行排序"></a>基于TF（Term Frequency，词频）进行排序</h1><p>最容易想到的便是基于词频打分进行排序，具体来说，对于查询Query：“林俊杰/2019/演唱会/行程”，下面的哪个网页跟查询Query的相关度更高呢？<br><strong>网页a</strong></p>
<pre><code>[林俊杰]/[2019]/全球/[演唱会]/[行程]/发布/，/这是/[林俊杰]/的/第/20/场/全球/巡演/。
</code></pre><table>
<thead>
<tr>
<th>关键字</th>
<th>出现频次</th>
</tr>
</thead>
<tbody>
<tr>
<td>林俊杰</td>
<td>2</td>
</tr>
<tr>
<td>2019</td>
<td>1</td>
</tr>
<tr>
<td>演唱会</td>
<td>1</td>
</tr>
<tr>
<td>行程</td>
<td>1</td>
</tr>
</tbody>
</table>
<p><strong>网页b</strong></p>
<pre><code>在 [林俊杰]/[2019]/全球/[演唱会]/[行程]/发布/之后/，/田馥甄/也/发布/了/今年/的/巡演/计划/，/她的/第一站/是/台北/。
</code></pre><table>
<thead>
<tr>
<th>关键字</th>
<th>出现频次</th>
</tr>
</thead>
<tbody>
<tr>
<td>林俊杰</td>
<td>1</td>
</tr>
<tr>
<td>2019</td>
<td>1</td>
</tr>
<tr>
<td>演唱会</td>
<td>1</td>
</tr>
<tr>
<td>行程</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>显然网页a和Query的相关度更高。当然对于计算机就没有这么“显然”了，它需要依靠规则和具体算法来计算判断。基于词频的排序用公式表示就是，<br>    <img src="https://upload-images.jianshu.io/upload_images/4905018-2166358dc8c2fbae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="相关性计算"><br>其中，<br>k：Query中查询关键词序号<br><img src="https://upload-images.jianshu.io/upload_images/4905018-8c341c80a496862e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="参数说明"></p>
<p>为了方便计算，我们假设每个网页包含的词的总数为100，通过上面的公式，<br><strong>网页a</strong></p>
<pre><code>网页a相关度=2/100+1/100+1/100+1/100=0.05
</code></pre><p><strong>网页b</strong></p>
<pre><code>网页b相关度=1/100+1/100+1/100+1/100=0.04
</code></pre><p>通过上面的公式，计算机也能“显然”的判断，网页a与查询Query的相关度更高了。</p>
<h1 id="基于TF排序的问题"><a href="#基于TF排序的问题" class="headerlink" title="基于TF排序的问题"></a>基于TF排序的问题</h1><p>假设现在有新的召回网页，<br><strong>网页c</strong></p>
<pre><code>在 [林俊杰]/[2019]/全球/[演唱会]/[行程]/发布/之后/，/众多/明星/也/都/发布/了/自己/[2019]年/的/巡演/计划/，/[行程]/安排/如下/，
</code></pre><table>
<thead>
<tr>
<th>关键字</th>
<th>出现频次</th>
</tr>
</thead>
<tbody>
<tr>
<td>林俊杰</td>
<td>1</td>
</tr>
<tr>
<td>2019</td>
<td>2</td>
</tr>
<tr>
<td>演唱会</td>
<td>1</td>
</tr>
<tr>
<td>行程</td>
<td>2</td>
</tr>
</tbody>
</table>
<pre><code>网页c相关度=1/100+2/100+1/100+2/100=0.06
</code></pre><p>显然基于词频的相关性计算公式，网页c（相关度0.06）大于网页a（相关度0.05），但真实情况是，网页c和查询Query的相关度，并没有网页a大。</p>
<h1 id="IDF（Inverse-DocumentFrequency，逆文件词频）"><a href="#IDF（Inverse-DocumentFrequency，逆文件词频）" class="headerlink" title="IDF（Inverse DocumentFrequency，逆文件词频）"></a>IDF（Inverse DocumentFrequency，逆文件词频）</h1><p>上面的问题关键在于用户的查询Query主要关注的是”<strong>林俊杰</strong>“，至于”<strong>2019</strong>“，”<strong>行程</strong>“等信息也是在<strong>林俊杰</strong>的基础上展开的。所以，现在要解决的问题便是，排序算法如何能够凸显出”<strong>林俊杰</strong>“这个关键的查询信息。在这里便引入了IDF（Inverse DocumentFrequency，逆文件词频）。<br>我们先看下它的定义：<br><img src="https://upload-images.jianshu.io/upload_images/4905018-7e6f8bbd74473dc1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="IDF定义"><br>其中，<br>分母的+1操作，是为了避免当所有文档都不包含该关键词时，分母出现为0的情况。<br>IDF的分子是固定的，所以，IDF的特性主要体现在分母上。<br>从IDF的定义可以看出，<br><strong>1 越是能代表特定内容的关键词，包含该关键词的网页越少，IDF值越高，如“林俊杰”</strong><br><strong>2 越是和内容主旨不相关的关键词，包含该关键词的网页越多，IDF值越低，如“2019”，“行程”</strong><br>所以，IDF值就能很好的体现出查询Query关键字，与需要查询内容的相关性。</p>
<h1 id="基于TF-IDF进行排序"><a href="#基于TF-IDF进行排序" class="headerlink" title="基于TF-IDF进行排序"></a>基于TF-IDF进行排序</h1><p>结合TF和IDF的特定，便有了TF-IDF，定义也非常直观，<br><img src="https://upload-images.jianshu.io/upload_images/4905018-ad1332e689276ef9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TF-IDF"><br>具体来说就是，一个网页与查询Query的相关性体现在：<br><strong>1 网页中包含查询关键词的频度</strong><br><strong>2 查询关键词对查询内容的反映程度</strong><br>基于TF-IDF，网页与查询Query的相关性，改写为，<br><img src="https://upload-images.jianshu.io/upload_images/4905018-de1a33712251872a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="相关性定义"><br>其中，<br><img src="https://upload-images.jianshu.io/upload_images/4905018-db90ca37a0c4ec6a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="参数说明"><br>在实际工程中，TF和IDF值，以及TF-IDF值针对于具体网页是提前计算好的，当搜索系统接收到用户的查询Query后，能够实时计算查询关键词与网页的相关度。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本文沿用了<a href="https://zhuanlan.zhihu.com/p/55296265" target="_blank" rel="external">《《从零开始学习自然语言处理(NLP)》-倒排索引(1)》</a>中搜索的例子，提出了在网页包含所有查询关键词的情况下，如何对网页与查询Query的相关性进行排序。文中提出了基于TF的相关性排序方法，同时，也指出了该方法存在的问题。最终，引出TF-IDF算法：结合查询关键词在网页中的出现频率和该关键词反映查询内容程度两个特征，对召回网页进行排序。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/20/《从零开始学习自然语言处理-NLP-》-倒排索引-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liu Caiquan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="才权的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/01/20/《从零开始学习自然语言处理-NLP-》-倒排索引-1/" itemprop="url">
                  《从零开始学习自然语言处理(NLP)》-倒排索引(1)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-20T11:09:47+08:00">
                2019-01-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>由于图片外链被禁止了，图片不能显示，完整文章看这里吧：<a href="https://zhuanlan.zhihu.com/p/55296265" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/55296265</a></p>
<h1 id="写在最前面"><a href="#写在最前面" class="headerlink" title="写在最前面"></a>写在最前面</h1><p>在这个日新月异的信息时代，海量数据的积累，计算能力的不断提升，机器学习尤其是深度学习的蓬勃发展，使得人工智能技术在不同领域焕发出蓬勃的活力。自己经历了嵌入式开发，移动互联网开发，目前从事自然语言处理算法开发工作。从工程软件开发到自然语言处理算法开发，希望通过这个系列的文章，能够由浅入深，通俗易懂的介绍自然语言处理的领域知识，分享自己的成长，同大家一起进步。</p>
<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>倒排索引是搜索引擎的基础算法，在本文中我们以一个简单的例子来详细介绍倒排索引的思想和实现。<br>假设用户有个搜索query：“林俊杰2019演唱会行程”。百度的搜索结果如下：<br><img src="https://upload-images.jianshu.io/upload_images/4905018-25e46b27de0ebfdd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="百度搜索结果"><br>如果要求你来设计一个搜索引擎，来解决这个问题，你会如何着手呢？</p>
<h1 id="问题简化"><a href="#问题简化" class="headerlink" title="问题简化"></a>问题简化</h1><p>现在我们把这个问题具体化。我们除了有要查询的query：“林俊杰2019演唱会行程”。还有被查询的网页数据库。这里我们做个简化，假设我们的网页数据库内容只有如下4条：<br><strong>网页1：</strong></p>
<pre><code>2019年，JJ林俊杰全球演唱会在北京首场演出，行程如下xxxxxxx；
</code></pre><p><strong>网页2：</strong></p>
<pre><code>林俊杰，吴亦凡终于同框合影 ，惹粉丝们尖叫连连，xxxxx；
</code></pre><p><strong>网页3：</strong></p>
<pre><code>蔡依林2019世界演唱会行程全曝光，xxxxx；
</code></pre><p><strong>网页4：</strong></p>
<pre><code>告别2018，迎接崭新的2019，xxxxxx；
</code></pre><p>简单来说，就是从网页1~4中选取最理想的查询结果。你会怎么做呢？</p>
<h1 id="关键词匹配"><a href="#关键词匹配" class="headerlink" title="关键词匹配"></a>关键词匹配</h1><p>最容易想到的方法就是关键词匹配了，简单的来说，就是网页中包含查询的关键词越多，网页和查询query的相关度也就越大。<br>在做关键词查询前，一般文本会先进行预处理。这里的预处理主要包括去停用词和分词。<br><strong>去停用词</strong><br>去除和查询不相关的内容，比如本例子中的标点符号。在其他场景中，除了标点符号也会去除一些特别的字或词。<br><strong>分词</strong><br>分词主要目的是将句子切长短语或关键字，这样才利于查询匹配。比如“林俊杰2019演唱会行程”可以分词成，</p>
<pre><code>林俊杰/2019/演唱会/行程
</code></pre><p>当然网页也需要这样进行分词：<br><strong>网页1：</strong></p>
<pre><code>2019/年/JJ/林俊杰/全球/演唱会/在/北京/首场/演出/行程/如下/xxxxxxx
</code></pre><p><strong>网页2：</strong></p>
<pre><code>林俊杰/吴亦凡/终于/同框/合影 /惹/粉丝们/尖叫/连连/xxxxx
</code></pre><p><strong>网页3：</strong></p>
<pre><code>蔡依林/2019/世界/演唱会/行程/全曝光/xxxxx
</code></pre><p><strong>网页4：</strong></p>
<pre><code>告别/2018/迎接/崭新/的/2019/xxxxxx；
</code></pre><p>分词是一项专门的技术，在实际工程中可以至今借助工具来完成，比如<a href="https://github.com/fxsjy/jieba" target="_blank" rel="external">jieba分词</a>。<br>分词处理后，我们用查询query中的关键词在网页数据库中进行关键词匹配，并统计匹配数目：</p>
<table>
<thead>
<tr>
<th>网页序号</th>
<th>匹配关键词</th>
<th>匹配个数</th>
</tr>
</thead>
<tbody>
<tr>
<td>网页1</td>
<td>2019，林俊杰，演唱会，行程</td>
<td>4</td>
</tr>
<tr>
<td>网页2</td>
<td>林俊杰</td>
<td>1</td>
</tr>
<tr>
<td>网页3</td>
<td>2019，演唱会，行程</td>
<td>3</td>
</tr>
<tr>
<td>网页4</td>
<td>2019</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>从“匹配个数”中很容易确定，网页1就是和查询query最匹配的网页。</p>
<h1 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h1><p>讲到这里大家可能会疑问，这和倒排索引有什么关系？实际上，如果仔细考虑上面的关键词查询过程，会发现这种方法有个很大的效率问题：我们的例子中只有4个待查询的网页，而实际的互联网世界的网页数目是非常巨大的。假设互联网世界的网页数据为N，那么使用关键词查询的时间复杂度就是O(N)，显然，这样的时间复杂度还是太大了，而倒排索引就很好的优化了这个问题。<br>从倒排索引这个名字很容易联想出它的实现，关键就是“倒排”的“索引”。在前面的讲解中，我们的索引(key)是网页，内容(value)是关键字。倒排索引就是反过来：内容关键字作为索引(key)，所在网页作为内容(value)。前面的表格就可以改写成，</p>
<table>
<thead>
<tr>
<th>关键词</th>
<th>包含关键词的网页</th>
</tr>
</thead>
<tbody>
<tr>
<td>林俊杰</td>
<td>网页1，网页2</td>
</tr>
<tr>
<td>2019</td>
<td>网页1，网页3，网页4</td>
</tr>
<tr>
<td>演唱会</td>
<td>网页1，网页3,</td>
</tr>
<tr>
<td>行程</td>
<td>网页1，网页3</td>
</tr>
</tbody>
</table>
<p>通过上面的表格，很明显网页1是包含最多关键词的网页，也是和查询query相关度最高的网页。采用倒排索引的方法，搜索的时间复杂度得到了明显的降低。</p>
<h1 id="搜索引擎框架"><a href="#搜索引擎框架" class="headerlink" title="搜索引擎框架"></a>搜索引擎框架</h1><p>有了倒排索引的知识，我们就可以搭建简单的搜索引擎了，<br><img src="https://upload-images.jianshu.io/upload_images/4905018-0cc45397fced1b35.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="搜索引擎框架"><br>具体步骤包括：<br><strong>网页抓取</strong><br>主要是借助网络爬虫，来抓取网络世界的所有网页，并进行存储。网络爬虫是一项专门的技术，目前工程上也有很多现成的开源工具。<br><strong>倒排索引生成</strong><br>将抓取后的网页经过预处理后，整理生成倒排索引。<br><strong>用户在线查询</strong><br>借助倒排索引，搜索引擎能够满足用户的实时在线查询。<br>前两个步骤是不用考虑实时性的，可以离线进行，而用户的在线查询则需要保证实时性。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本文通过一个搜索查询的例子，引出关键词查询的方案，及遇到的问题。进而介绍了倒排索引的原理，和搜索引擎的整体框架。现代搜索引擎是一个非常庞大和复杂的系统工程，这里的例子只是为了方便大家理解做了特别的简化。文中提到的分词和网络爬虫也是专门的文本处理技术，在后续的文章后，会根据需要专门展开。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/12/《从零开始学习自然语言处理-NLP-》-基础准备-0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liu Caiquan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="才权的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/01/12/《从零开始学习自然语言处理-NLP-》-基础准备-0/" itemprop="url">
                  《从零开始学习自然语言处理(NLP)》-基础准备(0)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-12T22:11:22+08:00">
                2019-01-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>由于图片外链被禁止了，图片不能显示，完整文章看这里吧：<a href="https://zhuanlan.zhihu.com/p/54731715" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/54731715</a></p>
<h1 id="写在最前面"><a href="#写在最前面" class="headerlink" title="写在最前面"></a>写在最前面</h1><p>在这个日新月异的信息时代，海量数据的积累，计算能力的不断提升，机器学习尤其是深度学习的蓬勃发展，使得人工智能技术在不同领域焕发出蓬勃的活力。自己经历了嵌入式开发，移动互联网开发，目前从事自然语言处理算法开发工作。从工程软件开发到自然语言处理算法开发，希望通过这个系列的文章，能够由浅入深，通俗易懂的介绍自然语言处理的领域知识，分享自己的成长，同大家一起进步。</p>
<h1 id="信心与兴趣"><a href="#信心与兴趣" class="headerlink" title="信心与兴趣"></a>信心与兴趣</h1><p>很多同学提到算法可能就会打退堂鼓，尤其是一直从事纯工程的软件开发。工作中连经典的数据结构都很少使用，更不用提五花八门的机器学习和深度学习算法。尤其各个大厂的算法专家、数据科学家都是背景爆表，动不动就是国外名校的Phd，至少也是国内清北、C9。实际上，针对普通的算法开发岗，从学习梯度上来讲，算法和工程的差异并不大。当然也并不需要非要名校硕博。<br>以前经常和同事开玩笑说，好歹大家都是985的本硕，但手上这工作，找个高中生也能妥妥搞定啊。虽然是玩笑，线上的产品当然也不是像Demo那么简单，但真实的工作真的没有那么明显的条条框框限制。自己也是面试官，百度这样的大厂对普通的开发要求也只是大专。针对普通的算法开发，自己觉得本科基本足够了，当然更没有像211/985这样的限制。<br>一般来讲，从事某个领域的工作，从底层基础到业务实现一般包括如下的几个层次（以互联网移动开发和算法开发为例）：</p>
<table>
<thead>
<tr>
<th>方向</th>
<th>通用基础</th>
<th>专业基础</th>
<th>领域基础</th>
<th>业务方向</th>
</tr>
</thead>
<tbody>
<tr>
<td>移动开发</td>
<td>操作系统、计算机网络、编译原理、数据结构、编程语言、设计模式</td>
<td>Android开发、iOS开发</td>
<td>驱动开发、Framework开发、应用开发</td>
<td>电商、社交、智能硬件</td>
</tr>
<tr>
<td>算法开发</td>
<td>编程语言(python)、数学基础(线性代数、概率/统计、微积分)</td>
<td>机器学习，深度学习</td>
<td>语音、自然语言理解、计算机视觉、推荐、计算广告、风控</td>
<td>搜索，智能客服，广告推荐，互联网金融</td>
</tr>
</tbody>
</table>
<p>从技能栈的对比来看，算法开发对数学要求要高些，这又会让很多同学看着头痛。实际上对数学的恐惧主要原因在于，对大多数人来说，数学主要是用来应付作业和考试的，而很少在真实的工程场景中使用它。<br>自己的本科专业是电子信息方向（觉得空闲时间多，顺手拿了个计算机科学与技术的双学士），有一些专业课程也蛮让人头痛的，比如《通信原理》、《信号与系统》、《数字信号处理》、《微机原理》、《数字电路》等，五花八门的抽象概念和算法公式。当时参加全国大学生电子设计竞赛，选入的学校的电子设计校队，参加系统的学习和培训（有半年的时间参加集中培训，不用像其他同学一样日常上课）：<br>当大家还在纠结《通信系统》里的调制解调原理时，我们已经在做单边带调制收音机了；<br>当大家还在纠结《信号与系统》的傅里叶变换时，我们已经在做基于快速傅里叶变换的频谱仪了；<br>当大家还在纠结《数字信号处理》里的滤波器时，我们已经在做50Hz及其谐波过滤的工频陷波器了；<br>当大家还在纠结《微机原理》的X86汇编指令时，我们已经用上工业级的Msp430和C8051F系列控制器了；<br>当大家还在纠结《数字电路》的逻辑控制和抱怨VHDL难学时，我们已经在用Verilog玩Altera的FPGA了。<br>本来是非常枯燥有难以对付的专业课，但有了实际的使用场景和工程实践，反而变得非常有趣，不但专业课的教材就在手边经常翻阅，还会专门找相应的Paper，看看有没有更好更新的方案。自己对这些专业课不但没有反感，反而觉得超级有用，知识就是力量，在这一刻特别贴切。<br>我们回过头来说数学，也是同样的体验。算法的开发工作为数学和算法提供了实践的土壤，理论有了实践这块沃土，也就不再那么枯燥和晦涩。像很多数学大神一样徒手推公式确实是件很难的事情，但基于基础的数学知识来解决工程问题，这并没有想象中的那么难。而且，学习本来就是一个往复的过程，先有一个大概，尝试用已有的知识解决问题，当问题解决不掉时，再反过来学习自己欠缺的知识。<br>说了信心再说兴趣，很多同学会觉得目前机器学习和深度学习大火，是不是就该放弃手上的工程岗位，全力以赴的加入到算法的大军中。自己觉得要不加入这个方向还是看个人兴趣吧，现在算法岗位炙手可热，但三五年之后就不好说了。典型的就是Android/iOS移动开发，10年左右如日中天，市场蓝海，人才紧俏，公司抢人的盛况应该跟现在差不多。收益的决定因素是市场，但个人的成长从长期来看，还要看自己的兴趣。依照T型能力理论来说，深度方面，前端、后台、架构、嵌入式、客户端都OK；广度方面，机器学习和深度学习不论从是否要从事相关的领域开发，花些时间了解和学习一下，总的来说也还是不错的。<br>好了，下面我们就具体看看从事自然语言处理需要准备的基础知识吧。</p>
<h1 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h1><p>编程语言的要求是很低的，弄掌握Python就基本OK。我的自己经验是：</p>
<ul>
<li>1 在网上找一篇Python入门的帖子，搭建环境，运行简单的例子（半天）</li>
<li>2 找一本基础书籍，系统的熟悉下语言的基本特性和完整框架（1~2天）<br>ps：我之前有C/C++和Java的语音基础</li>
<li>3 开始正常使用Python进行开发，遇到问题，求助搜索引擎（2个月以上）</li>
<li>4 觉得自己对语言就基本的掌握后，可以根据选择进行进阶学习了</li>
</ul>
<p>系统的基础学习可以参考：<a href="https://item.jd.com/12279949.html" target="_blank" rel="external">《Python基础教程》</a><br>晋级学习可以参考：<a href="https://item.jd.com/12186192.html" target="_blank" rel="external">《流畅的Python》</a></p>
<h1 id="经典数据结构与算法"><a href="#经典数据结构与算法" class="headerlink" title="经典数据结构与算法"></a>经典数据结构与算法</h1><p>经典的数据结构和算法，主要指数组、链表、队列、堆栈、树、图这样的经典数据结构，以及各种排序/查找、深度搜索、广度搜索、最小路径、Hash等算法。对一般的算法开发，这部分不是必须项。如果时间有限，可以跳过这部分。但从长远来看，无论是普通的工程开发还是算法开发，经典的数据结构和算法还是必要了。<br>落实到具体的学习上，基础的《数据结构与算法》应该随便一本教科书都OK。在实际操作方面，可以抽空刷一刷<a href="https://leetcode.com/" target="_blank" rel="external">LeetCode</a>，书的话可以考虑<a href="https://item.jd.com/39977813000.html" target="_blank" rel="external">《进军硅谷，程序员面试解密》</a>，内容基本都是LeetCode的原题，可以先刷题再看书。如果LeetCode上能持续刷上200+的题目，以后面对经典的数据结构和算法问题，应该也就没有恐惧的感觉了，反而遇到新问题还会饶有兴趣的去研究研究解决方案。</p>
<h1 id="数学基础"><a href="#数学基础" class="headerlink" title="数学基础"></a>数学基础</h1><p>对于算法开发，本科学习的《微积分》、《线性代数》、《概率/统计》基本上就够用了。有些同学会提到《概率图模型》和《凸优化》等。我觉得对于入门来说，前面的三门课基本够用，后面如果真的觉得需要深入，再看后面的内容也不迟。<br>如果觉得当时大学的课程成绩还不错，那最快的方法就是把大学的教材拿出来重新再扫一般即可。如果觉得时间充裕，想再系统的学习一遍，在线视频是个不错的选择，<br><a href="http://open.163.com/special/sp/singlevariablecalculus.html" target="_blank" rel="external">MIT：《单变量微积分》</a><br><a href="http://open.163.com/special/opencourse/daishu.html" target="_blank" rel="external">MIT：《线性代数》</a><br><a href="http://open.163.com/special/Khan/probability.html" target="_blank" rel="external">可汗学院：《概率》</a><br><a href="http://open.163.com/special/Khan/khstatistics.html" target="_blank" rel="external">可汗学院：《统计学》</a><br>学习的过程不要太苛求全面理解，没必要像数学大牛一样能把所有的公式都手动的推导一遍。能理解基本的概念和原理，关键是有系统的知识框架，后面遇到细节问题，可以回过头来再看。</p>
<h1 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h1><p>这部分目前资料应该是铺天盖地的多，当然还有各式各样的培训班。自己觉得从入门角度，只要把吴恩达在Coursera上的机器学习课程完整的学习完，并完成作业拿到证书，机器学习这部分就算及格了。<br><a href="https://www.coursera.org/learn/machine-learning" target="_blank" rel="external">Coursera：《MachineLearning》</a><br>一定要完成作业！一定要完成作业！一定要完成作业！重要的事情说三遍。<br>Coursera不翻墙速度好像有些慢，网易云课堂也有视频，但不能提交作业作业。<br>至于书的话，可以看看周志华老师的“西瓜书”：<a href="https://item.jd.com/11867803.html" target="_blank" rel="external">《机器学习》</a></p>
<h1 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h1><p>看完前面机器学习的内容你会发现两个事情：</p>
<ul>
<li>机器学习的各种算法好像都是些非常经典的算法，基本都是2000年之前提出的</li>
<li>现在大家都在搞深度学习了，这些老掉牙的算法越来越没人用了</li>
</ul>
<p>真实情况也大抵如此，如果直接跳过机器学习直接学习深度学习可以吗？当然可以啊，而且，直接学习深度学习还会觉得深度学习的入门门槛更低。<br>这估计会让很多同学觉得反常识。但反过来你问问自己，如果没有学习过汇编，上来就用C语言搞嵌入式应用开发可以吗？没有学习过C++，上来就用Java搞Android开发可以吗？当然可以啊。从入门角度没问题，但从长期来看还是需要的，想深入一个领域，知识的完备是必要的。比如嵌入开发用汇编写过两级中断向量表，做Android开发也开发过JNI。<br>深度学习也是一样，从最快入门的角度来看，可以跳过机器学习，直接进入深度学习，但从长期看机器学习还是必要的。而且，看完了吴恩达的《机器学习》课程，再看他的深度学习也更流畅。<br><a href="https://mooc.study.163.com/smartSpec/detail/1001319001.htm" target="_blank" rel="external">Coursera：《DeepLearning》</a><br>一定要完成作业！一定要完成作业！一定要完成作业！重要的事情说三遍。<br>补充下，吴恩达在Coursera上的课程，《MachineLearning》是免费观看的，在线作业是付费的。《DeepLearning》无论是视频还是在线作业都是付费的。网易云课堂有免费的视频课程，但不能提交在线作业。其实，Coursera上的课程也挺便宜的，做完作业还有证书，还是挺不错的。<br>至于书的话，可以看看“花书”<a href="https://item.jd.com/12128543.html" target="_blank" rel="external">《深度学习》</a></p>
<h1 id="自然语言处理"><a href="#自然语言处理" class="headerlink" title="自然语言处理"></a>自然语言处理</h1><p>好了终于到了这篇文章的核心部分了，因为是专业基础，所有市面上的系统学习资料也就没前面那么多了。但仔细找找的话也不少（都需要翻墙，手动捂脸）：<br>经典自然语言处理（斯坦福）：<a href="https://www.youtube.com/playlist?list=PLQiyVNMpDLKnZYBTUOlSI9mi9wAErFtFm" target="_blank" rel="external">《Natural Language Processing course by Dan Jurafsky and Christopher Manning》</a><br>经典+深度学习（National Research University Higher School of Economics）：<a href="https://www.coursera.org/learn/language-processing" target="_blank" rel="external">《Natural Language Processing》</a><br>深度学习自然语言处理（斯坦福）：<a href="https://www.youtube.com/playlist?list=PL3FW7Lu3i5Jsnh1rnUwq_TcylNr7EkRe6" target="_blank" rel="external">《Natural language processing with DeepLearning》</a><br>深度学习自然语言处理（CMU）：<a href="https://www.youtube.com/playlist?list=PL8PYTP1V4I8Ba7-rY4FoB4-jfuJ7VDKEE" target="_blank" rel="external">《CMU Neural Nets for NLP》</a><br>除了第一个之外，后面的视频都比较新。相对来说，书的资料就相对滞后了，如果有兴趣可以翻翻经典的宗成庆的<a href="https://item.jd.com/1040675628.html" target="_blank" rel="external">《统计自然语言处理》</a>，主要是针对经典的自然语言处理方法，虽然方法是经典的，但领域问题的描述还是很全面的。</p>
<h1 id="小节"><a href="#小节" class="headerlink" title="小节"></a>小节</h1><p>总的来说，算法开发和普通的工程开发，从学习梯度上来讲差别不大，也不需要高大上的背景和学历。确定兴趣，看好方向，就坚持一步一步积累，理论结合实践，相信很快你也能像我一样，跨过算法开发的门槛，体会用算法解决实际工程问题的乐趣。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/21/TensorFlow-Servering-C-S通信约束/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liu Caiquan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="才权的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/09/21/TensorFlow-Servering-C-S通信约束/" itemprop="url">
                  TensorFlow Servering C/S通信约束
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-21T17:30:10+08:00">
                2018-09-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>由于图片外链被禁止了，图片不能显示，完整文章看这里吧：<a href="https://zhuanlan.zhihu.com/p/45109527" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/45109527</a></p>
<p>TensorFlow Serving以Server方式提供模型能力服务，作为服务的使用者（Client）可以通过gRPC和RESTfull API两种方式来获取模型能力。虽然TensorFlow对C/S的通信约束做了说明，但感觉介绍的并不是特别的清晰易用，需要自己根据使用示例，并结合文档进行梳理和总结。</p>
<h1 id="官方参考示例"><a href="#官方参考示例" class="headerlink" title="官方参考示例"></a>官方参考示例</h1><p>在文档中提到了两个参考示例，一个用于gRPC通信约束测试，一个用于RESTfull API通信约束测试。</p>
<h2 id="1-gRPC示例"><a href="#1-gRPC示例" class="headerlink" title="1. gRPC示例"></a>1. gRPC示例</h2><p>示例使用说明：<a href="https://www.tensorflow.org/serving/serving_basic" target="_blank" rel="external">https://www.tensorflow.org/serving/serving_basic</a></p>
<ul>
<li>模型输出</li>
</ul>
<p>minist_save_model.py<br>示例代码：<a href="https://github.com/tensorflow/serving/blob/master/tensorflow_serving/example/mnist_saved_model.py" target="_blank" rel="external">https://github.com/tensorflow/serving/blob/master/tensorflow_serving/example/mnist_saved_model.py</a></p>
<ul>
<li>客户端验证</li>
</ul>
<p>mnist_client.py<br>示例代码：<a href="https://github.com/tensorflow/serving/blob/master/tensorflow_serving/example/mnist_client.py" target="_blank" rel="external">https://github.com/tensorflow/serving/blob/master/tensorflow_serving/example/mnist_client.py</a></p>
<h2 id="2-RESTfull-API示例"><a href="#2-RESTfull-API示例" class="headerlink" title="2. RESTfull API示例"></a>2. RESTfull API示例</h2><p>示例使用说明:<a href="https://www.tensorflow.org/serving/api_rest" target="_blank" rel="external">https://www.tensorflow.org/serving/api_rest</a></p>
<ul>
<li>模型输出</li>
</ul>
<p>export_half_plus_two.py<br>示例代码：<br><a href="https://github.com/tensorflow/serving/blob/master/tensorflow_serving/servables/tensorflow/testdata/export_half_plus_two.py" target="_blank" rel="external">https://github.com/tensorflow/serving/blob/master/tensorflow_serving/servables/tensorflow/testdata/export_half_plus_two.py</a></p>
<ul>
<li>客户端验证</li>
</ul>
<p>Http请求，通过curl命令完成</p>
<h1 id="示例代码分析"><a href="#示例代码分析" class="headerlink" title="示例代码分析"></a>示例代码分析</h1><p>虽然官网提供了两个示例，但实际上RESTfull API的示例过于简单，并且做了封装，实际的参考价值不大。下面主要结合gRPC的示例代码进行分析。</p>
<p>客户端同服务端进行通信交互的核心是几个标识，我们分别介绍下。</p>
<h2 id="1-模型标识"><a href="#1-模型标识" class="headerlink" title="1. 模型标识"></a>1. 模型标识</h2><p>指定要使用哪一个模型。<br>参考mnist_client.py<br><img src="https://upload-images.jianshu.io/upload_images/4905018-096c9d8c7179e212.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="模型标识"><br>模型标识在Serving的模型保存输出代码中并没有显示的声明。模型标识实际上是在指定模型输出路径，和设置TF Serving “target”时指定的。<br><img src="https://upload-images.jianshu.io/upload_images/4905018-08d42983a3c994d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="设置模型标识"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/4905018-ddbcb11c57d6b1a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="设置模型标识"><br>参考:<a href="https://www.tensorflow.org/serving/serving_basic" target="_blank" rel="external">https://www.tensorflow.org/serving/serving_basic</a></p>
<h2 id="2-签名标识"><a href="#2-签名标识" class="headerlink" title="2. 签名标识"></a>2. 签名标识</h2><p>可以粗糙的理解为，用来指定需要调用模型中的哪个方法。<br>官网定义（参考：<a href="https://www.tensorflow.org/serving/signature_defs" target="_blank" rel="external">https://www.tensorflow.org/serving/signature_defs</a>）<br><img src="https://upload-images.jianshu.io/upload_images/4905018-f11fe8bf94deb985.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="签名标识"></p>
<p>参考mnist_client.py<br><img src="https://upload-images.jianshu.io/upload_images/4905018-590604b058572893.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="签名标识"><br>签名标识在Serving的模型保存输出代码中设置，<br>参考minist_save_model.py<br><img src="https://upload-images.jianshu.io/upload_images/4905018-93b045830786fc5f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="签名标识"></p>
<h2 id="3-输入标识"><a href="#3-输入标识" class="headerlink" title="3. 输入标识"></a>3. 输入标识</h2><p>设置输入，传入待处理的数据。<br>官网定义（参考：<a href="https://www.tensorflow.org/serving/signature_defs" target="_blank" rel="external">https://www.tensorflow.org/serving/signature_defs</a>）<br><img src="https://upload-images.jianshu.io/upload_images/4905018-b2a8ffbd46651a52.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="输入标识"><br>参考minist_save_model.py<br><img src="https://upload-images.jianshu.io/upload_images/4905018-db79f2f06f1aab81.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="输入标识"><br>参考mnist_client.py<br><img src="https://upload-images.jianshu.io/upload_images/4905018-1ce83967311b7195.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="输入标识"></p>
<h2 id="4-输出标识"><a href="#4-输出标识" class="headerlink" title="4. 输出标识"></a>4. 输出标识</h2><p>设置哪些数据作为返回值，只在Serving中进行设置，Client获取的返回值中，能够获取对应的标识。<br>官网定义（参考：<a href="https://www.tensorflow.org/serving/signature_defs" target="_blank" rel="external">https://www.tensorflow.org/serving/signature_defs</a>）<br><img src="https://upload-images.jianshu.io/upload_images/4905018-cdc8753f3d8a631e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="输出标识"><br>参考minist_save_model.py<br><img src="https://upload-images.jianshu.io/upload_images/4905018-4fd54685229a5f5c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="输出标识"><br>参考mnist_client.py<br><img src="https://upload-images.jianshu.io/upload_images/4905018-c787b908032f977b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="输出标识"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>客户端向服务端发起请求时，指定了模型标识、签名标识、输入标识（包含数据），便可以从服务端获取处理结果，结果中包含输出标识。<br>gRPC和RESTfull API在通信约束上是一致的。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/21/TensorFlow-Serving入门/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liu Caiquan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="才权的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/09/21/TensorFlow-Serving入门/" itemprop="url">
                  TensorFlow Serving入门
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-21T17:21:28+08:00">
                2018-09-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>由于图片外链被禁止了，图片不能显示，完整文章看这里吧：<a href="https://zhuanlan.zhihu.com/p/45109194" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/45109194</a></p>
<p>大家习惯使用TensorFlow进行模型的训练、验证和预测，但模型完善之后的生产上线流程，就变得五花八门了。针对这种情况Google提供了TensorFlow Servering，可以将训练好的模型直接上线并提供服务。在2017年的TensorFlow开发者Summit上便提出了TensorFlow Serving。<br>传送门：<a href="https://www.youtube.com/watch?v=q_IkJcPyNl0&amp;list=PLOU2XLYxmsIKGc_NBoIhTn2Qhraji53cv&amp;index=13" target="_blank" rel="external">https://www.youtube.com/watch?v=q_IkJcPyNl0&amp;list=PLOU2XLYxmsIKGc_NBoIhTn2Qhraji53cv&amp;index=13</a><br>但那时候客户端和服务端的通信只支持gRPC。在实际的生产环境中比较广泛使用的C/S通信手段是基于RESTfull API的，幸运的是从TF1.8以后，TF Serving也正式支持RESTfull API通信方式了。</p>
<h2 id="服务框架"><a href="#服务框架" class="headerlink" title="服务框架"></a>服务框架</h2><p><img src="https://upload-images.jianshu.io/upload_images/4905018-913e07a93c4821ee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TF Serving服务框架"><br>基于TF Serving的持续集成框架还是挺简明的，基本分三个步骤：</p>
<ul>
<li>模型训练<br>这是大家最熟悉的部分，主要包括数据的收集和清洗、模型的训练、评测和优化；</li>
<li>模型上线<br>前一个步骤训练好的模型在TF Server中上线；</li>
<li>服务使用</li>
</ul>
<p>客户端通过gRPC和RESTfull API两种方式同TF Servering端进行通信，并获取服务；</p>
<h1 id="TF-Serving工作流程"><a href="#TF-Serving工作流程" class="headerlink" title="TF Serving工作流程"></a>TF Serving工作流程</h1><p><img src="https://upload-images.jianshu.io/upload_images/4905018-560bf34c3a9e5aca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TF Serving工作流程"><br>TF Serving的工作流程主要分为以下几个步骤：</p>
<ul>
<li>Source会针对需要进行加载的模型创建一个Loader，Loader中会包含要加载模型的全部信息；</li>
<li>Source通知Manager有新的模型需要进行加载；</li>
<li>Manager通过版本管理策略（Version Policy）来确定哪些模型需要被下架，哪些模型需要被加载；</li>
<li>Manger在确认需要加载的模型符合加载策略，便通知Loader来加载最新的模型；</li>
<li>客户端像服务端请求模型结果时，可以指定模型的版本，也可以使用最新模型的结果；</li>
</ul>
<h1 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h1><p>TF Serving客户端和服务端的通信方式有两种（gRPC和RESTfull API）</p>
<h2 id="示例（一）：RESTfull-API形式"><a href="#示例（一）：RESTfull-API形式" class="headerlink" title="示例（一）：RESTfull API形式"></a>示例（一）：RESTfull API形式</h2><h3 id="1-准备TF-Serving的Docker环境"><a href="#1-准备TF-Serving的Docker环境" class="headerlink" title="1. 准备TF Serving的Docker环境"></a>1. 准备TF Serving的Docker环境</h3><p>目前TF Serving有Docker、APT（二级制安装）和源码编译三种方式，但考虑实际的生产环境项目部署和简单性，推荐使用Docker方式。</p>
<pre><code># docker pull tensorflow/serving
</code></pre><h3 id="2-下载官方示例代码"><a href="#2-下载官方示例代码" class="headerlink" title="2. 下载官方示例代码"></a>2. 下载官方示例代码</h3><p>示例代码中包含已训练好的模型和与服务端进行通信的客户端（RESTfull API形式不需要专门的客户端）</p>
<pre><code># mkdir -p /tmp/tfserving
# cd /tmp/tfserving
# git clone https://github.com/tensorflow/serving
</code></pre><h3 id="3-运行TF-Serving"><a href="#3-运行TF-Serving" class="headerlink" title="3. 运行TF Serving"></a>3. 运行TF Serving</h3><pre><code># docker run -p 8501:8501 \
  --mount type=bind,\
   source=/tmp/tfserving/serving/tensorflow_serving/servables/tensorflow/testdata/saved_model_half_plus_two_cpu,\
target=/models/half_plus_two \
-e MODEL_NAME=half_plus_two -t tensorflow/serving &amp;
</code></pre><p>这里需要注意的是，较早的docker版本没有“–mount”选项，比如Ubuntu16.04默认安装的docker就没有（我的环境是Ubuntu 18.04）。</p>
<h3 id="4-客户端验证"><a href="#4-客户端验证" class="headerlink" title="4.客户端验证"></a>4.客户端验证</h3><pre><code># curl -d &apos;{&quot;instances&quot;: [1.0, 2.0, 5.0]}&apos; \
  -X POST http://localhost:8501/v1/models/half_plus_two:predict 
</code></pre><p>返回结果，</p>
<pre><code># { &quot;predictions&quot;: [2.5, 3.0, 4.5] }
</code></pre><h2 id="示例（二）：gRPC形式"><a href="#示例（二）：gRPC形式" class="headerlink" title="示例（二）：gRPC形式"></a>示例（二）：gRPC形式</h2><h3 id="1-准备TF-Serving的Docker环境-1"><a href="#1-准备TF-Serving的Docker环境-1" class="headerlink" title="1. 准备TF Serving的Docker环境"></a>1. 准备TF Serving的Docker环境</h3><p>目前TF Serving有Docker、APT（二级制安装）和源码编译三种方式，但考虑实际的生产环境项目部署和简单性，推荐使用Docker方式。</p>
<pre><code>#  docker pull tensorflow/serving
</code></pre><h3 id="2-下载官方示例代码-1"><a href="#2-下载官方示例代码-1" class="headerlink" title="2. 下载官方示例代码"></a>2. 下载官方示例代码</h3><pre><code># mkdir -p /tmp/tfserving
# cd /tmp/tfserving
# git clone https://github.com/tensorflow/serving
</code></pre><h3 id="3-模型编译"><a href="#3-模型编译" class="headerlink" title="3. 模型编译"></a>3. 模型编译</h3><pre><code># python tensorflow_serving/example/mnist_saved_model.py models/mnist
</code></pre><h3 id="4-运行TF-Serving"><a href="#4-运行TF-Serving" class="headerlink" title="4. 运行TF Serving"></a>4. 运行TF Serving</h3><pre><code># docker run -p 8500:8500 \
--mount type=bind,source=$(pwd)/models/mnist,target=/models/mnist \
-e MODEL_NAME=mnist -t tensorflow/serving
</code></pre><p>这里需要注意的是，较早的docker版本没有“–mount”选项，比如Ubuntu16.04默认安装的docker就没有（我的环境是Ubuntu 18.04）。</p>
<h3 id="4-客户端验证-1"><a href="#4-客户端验证-1" class="headerlink" title="4.客户端验证"></a>4.客户端验证</h3><pre><code># python tensorflow_serving/example/mnist_client.py --num_tests=1000 --server=127.0.0.1:8500
</code></pre><p>返回结果，</p>
<pre><code>#  Inference error rate: 11.13%
</code></pre><p>这里需要注意的是，直接运行mnist_client.py会出现找不到“tensorflow_serving”的问题，需要手动安装，</p>
<pre><code># pip install tensorflow-serving-api
</code></pre><h1 id="资料参考"><a href="#资料参考" class="headerlink" title="资料参考"></a>资料参考</h1><p>TF Serving官方文档：<a href="https://www.tensorflow.org/serving/" target="_blank" rel="external">https://www.tensorflow.org/serving/</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Liu Caiquan" />
          <p class="site-author-name" itemprop="name">Liu Caiquan</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">68</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">11</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Liu Caiquan</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

<div>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
</div>



        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  





  





  






  





  

  

  

  

</body>
</html>
